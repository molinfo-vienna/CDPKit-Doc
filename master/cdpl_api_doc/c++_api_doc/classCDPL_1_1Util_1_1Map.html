<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chemical Data Processing Library C++ API - Version 1.3.0: CDPL::Util::Map&lt; Key, Value, AllowDefValues, KeyCompFunc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Chemical Data Processing Library C++ API - Version 1.3.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCDPL.html">CDPL</a></li><li class="navelem"><a class="el" href="namespaceCDPL_1_1Util.html">Util</a></li><li class="navelem"><a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classCDPL_1_1Util_1_1Map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CDPL::Util::Map&lt; Key, Value, AllowDefValues, KeyCompFunc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A unique sorted associative container that maps keys to values.  
 <a href="classCDPL_1_1Util_1_1Map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Map_8hpp_source.html">Map.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for CDPL::Util::Map&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCDPL_1_1Util_1_1Map__inherit__graph.svg" width="100%" height="524"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ada44e9cb54ee57510561f1a554a6fc3b"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ada44e9cb54ee57510561f1a554a6fc3b">SharedPointer</a></td></tr>
<tr class="memdesc:ada44e9cb54ee57510561f1a554a6fc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted smart pointer [<a class="el" href="References.html#SHPTR">SHPTR</a>] for dynamically allocated <code>Map</code> instances.  <a href="classCDPL_1_1Util_1_1Map.html#ada44e9cb54ee57510561f1a554a6fc3b">More...</a><br /></td></tr>
<tr class="separator:ada44e9cb54ee57510561f1a554a6fc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaee5a359ae386ddd06f97f40aa71e7"><td class="memItemLeft" align="right" valign="top">typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#addaee5a359ae386ddd06f97f40aa71e7">KeyType</a></td></tr>
<tr class="memdesc:addaee5a359ae386ddd06f97f40aa71e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map's keys.  <a href="classCDPL_1_1Util_1_1Map.html#addaee5a359ae386ddd06f97f40aa71e7">More...</a><br /></td></tr>
<tr class="separator:addaee5a359ae386ddd06f97f40aa71e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a734bb4066ae9a834ac63ebb45189b"><td class="memItemLeft" align="right" valign="top">typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ae8a734bb4066ae9a834ac63ebb45189b">ValueType</a></td></tr>
<tr class="memdesc:ae8a734bb4066ae9a834ac63ebb45189b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mapped values.  <a href="classCDPL_1_1Util_1_1Map.html#ae8a734bb4066ae9a834ac63ebb45189b">More...</a><br /></td></tr>
<tr class="separator:ae8a734bb4066ae9a834ac63ebb45189b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af108ab96e5d3d20fdde0bcd82fecfc4b"><td class="memItemLeft" align="right" valign="top">typedef StorageType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a></td></tr>
<tr class="memdesc:af108ab96e5d3d20fdde0bcd82fecfc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the key/value pairs stored in the map.  <a href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">More...</a><br /></td></tr>
<tr class="separator:af108ab96e5d3d20fdde0bcd82fecfc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765d6d413c29bf0f67aac146ac0b5c80"><td class="memItemLeft" align="right" valign="top">typedef StorageType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a></td></tr>
<tr class="memdesc:a765d6d413c29bf0f67aac146ac0b5c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator used to iterate over the entries of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">More...</a><br /></td></tr>
<tr class="separator:a765d6d413c29bf0f67aac146ac0b5c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710aa3a01de9ae9a820ddd5b6d6d8170"><td class="memItemLeft" align="right" valign="top">typedef StorageType::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">ConstReverseEntryIterator</a></td></tr>
<tr class="memdesc:a710aa3a01de9ae9a820ddd5b6d6d8170"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator used to iterate backwards over the entries of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">More...</a><br /></td></tr>
<tr class="separator:a710aa3a01de9ae9a820ddd5b6d6d8170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac699e0163375658aceffd56546fbfe71"><td class="memItemLeft" align="right" valign="top">typedef StorageType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a></td></tr>
<tr class="memdesc:ac699e0163375658aceffd56546fbfe71"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable iterator used to iterate over the entries of the map.  <a href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">More...</a><br /></td></tr>
<tr class="separator:ac699e0163375658aceffd56546fbfe71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20a40e0f2eb72335a94ea38997f2d4b"><td class="memItemLeft" align="right" valign="top">typedef StorageType::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">ReverseEntryIterator</a></td></tr>
<tr class="memdesc:aa20a40e0f2eb72335a94ea38997f2d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable iterator used to iterate backwards over the entries of the map.  <a href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">More...</a><br /></td></tr>
<tr class="separator:aa20a40e0f2eb72335a94ea38997f2d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa053665919da1172b8a006ebff526a84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa053665919da1172b8a006ebff526a84">Map</a> ()</td></tr>
<tr class="memdesc:aa053665919da1172b8a006ebff526a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty map.  <a href="classCDPL_1_1Util_1_1Map.html#aa053665919da1172b8a006ebff526a84">More...</a><br /></td></tr>
<tr class="separator:aa053665919da1172b8a006ebff526a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81fbb6d964c954135e9002728593215"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa81fbb6d964c954135e9002728593215">Map</a> (const KeyCompFunc &amp;func)</td></tr>
<tr class="memdesc:aa81fbb6d964c954135e9002728593215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty map and uses <em>func</em> as key compare function.  <a href="classCDPL_1_1Util_1_1Map.html#aa81fbb6d964c954135e9002728593215">More...</a><br /></td></tr>
<tr class="separator:aa81fbb6d964c954135e9002728593215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a822a4accdced3373f1ecc10f817646"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a5a822a4accdced3373f1ecc10f817646"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a5a822a4accdced3373f1ecc10f817646">Map</a> (const InputIter &amp;first, const InputIter &amp;last)</td></tr>
<tr class="memdesc:a5a822a4accdced3373f1ecc10f817646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em>.  <a href="classCDPL_1_1Util_1_1Map.html#a5a822a4accdced3373f1ecc10f817646">More...</a><br /></td></tr>
<tr class="separator:a5a822a4accdced3373f1ecc10f817646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb8d41c3b2e4555eaa14b8a77c8cd5a"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a6fb8d41c3b2e4555eaa14b8a77c8cd5a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a6fb8d41c3b2e4555eaa14b8a77c8cd5a">Map</a> (const InputIter &amp;first, const InputIter &amp;last, const KeyCompFunc &amp;func)</td></tr>
<tr class="memdesc:a6fb8d41c3b2e4555eaa14b8a77c8cd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em> and uses <em>func</em> as key compare function.  <a href="classCDPL_1_1Util_1_1Map.html#a6fb8d41c3b2e4555eaa14b8a77c8cd5a">More...</a><br /></td></tr>
<tr class="separator:a6fb8d41c3b2e4555eaa14b8a77c8cd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9680c51f3f3ef479e250f95e4ad77e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#adc9680c51f3f3ef479e250f95e4ad77e">~Map</a> ()</td></tr>
<tr class="memdesc:adc9680c51f3f3ef479e250f95e4ad77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classCDPL_1_1Util_1_1Map.html#adc9680c51f3f3ef479e250f95e4ad77e">More...</a><br /></td></tr>
<tr class="separator:adc9680c51f3f3ef479e250f95e4ad77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6247c4e24f849dbc9e6295c67eaeaa72"><td class="memItemLeft" align="right" valign="top">StorageType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a6247c4e24f849dbc9e6295c67eaeaa72">getData</a> ()</td></tr>
<tr class="separator:a6247c4e24f849dbc9e6295c67eaeaa72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cda1c602e3f8effdb0511ae39429bc5"><td class="memItemLeft" align="right" valign="top">const StorageType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a9cda1c602e3f8effdb0511ae39429bc5">getData</a> () const</td></tr>
<tr class="separator:a9cda1c602e3f8effdb0511ae39429bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba1b9320cc99543cf78d41b13961f25"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a3ba1b9320cc99543cf78d41b13961f25">getSize</a> () const</td></tr>
<tr class="memdesc:a3ba1b9320cc99543cf78d41b13961f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of entries) of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a3ba1b9320cc99543cf78d41b13961f25">More...</a><br /></td></tr>
<tr class="separator:a3ba1b9320cc99543cf78d41b13961f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625e5c2869343b56855cfc8da352ca1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a625e5c2869343b56855cfc8da352ca1a">isEmpty</a> () const</td></tr>
<tr class="memdesc:a625e5c2869343b56855cfc8da352ca1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the map is empty (<code><a class="el" href="classCDPL_1_1Util_1_1Map.html#a3ba1b9320cc99543cf78d41b13961f25" title="Returns the size (number of entries) of the map.">getSize()</a> == 0</code>).  <a href="classCDPL_1_1Util_1_1Map.html#a625e5c2869343b56855cfc8da352ca1a">More...</a><br /></td></tr>
<tr class="separator:a625e5c2869343b56855cfc8da352ca1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24a27ce1b3e781f6b8e66c5b4d056dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ab24a27ce1b3e781f6b8e66c5b4d056dd">clear</a> ()</td></tr>
<tr class="memdesc:ab24a27ce1b3e781f6b8e66c5b4d056dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all entries.  <a href="classCDPL_1_1Util_1_1Map.html#ab24a27ce1b3e781f6b8e66c5b4d056dd">More...</a><br /></td></tr>
<tr class="separator:ab24a27ce1b3e781f6b8e66c5b4d056dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a335f3768380a772b2b9ff77cebbed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a82a335f3768380a772b2b9ff77cebbed">swap</a> (<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> &amp;map)</td></tr>
<tr class="memdesc:a82a335f3768380a772b2b9ff77cebbed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents with <em>map</em>.  <a href="classCDPL_1_1Util_1_1Map.html#a82a335f3768380a772b2b9ff77cebbed">More...</a><br /></td></tr>
<tr class="separator:a82a335f3768380a772b2b9ff77cebbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b19a09b4296cea075d8809539ec635"><td class="memItemLeft" align="right" valign="top">KeyCompFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a25b19a09b4296cea075d8809539ec635">getKeyCompareFunction</a> () const</td></tr>
<tr class="memdesc:a25b19a09b4296cea075d8809539ec635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key compare function used by the map.  <a href="classCDPL_1_1Util_1_1Map.html#a25b19a09b4296cea075d8809539ec635">More...</a><br /></td></tr>
<tr class="separator:a25b19a09b4296cea075d8809539ec635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae18e922e17d653c9599e71cea6eab9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a8ae18e922e17d653c9599e71cea6eab9">getEntry</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a8ae18e922e17d653c9599e71cea6eab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the entry specified by <em>key</em>.  <a href="classCDPL_1_1Util_1_1Map.html#a8ae18e922e17d653c9599e71cea6eab9">More...</a><br /></td></tr>
<tr class="separator:a8ae18e922e17d653c9599e71cea6eab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed934d03788fef1750d8a4296dfed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#affed934d03788fef1750d8a4296dfed8">getEntry</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:affed934d03788fef1750d8a4296dfed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the entry specified by <em>key</em>.  <a href="classCDPL_1_1Util_1_1Map.html#affed934d03788fef1750d8a4296dfed8">More...</a><br /></td></tr>
<tr class="separator:affed934d03788fef1750d8a4296dfed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cbee71d8e0a18549e4a89e100ed9bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa0cbee71d8e0a18549e4a89e100ed9bb">containsEntry</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:aa0cbee71d8e0a18549e4a89e100ed9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the map contains an entry with the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#aa0cbee71d8e0a18549e4a89e100ed9bb">More...</a><br /></td></tr>
<tr class="separator:aa0cbee71d8e0a18549e4a89e100ed9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50893b806c98ea8c70518607b4c83b24"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a50893b806c98ea8c70518607b4c83b24">getValue</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a50893b806c98ea8c70518607b4c83b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-<code>const</code> reference to the value associated with the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#a50893b806c98ea8c70518607b4c83b24">More...</a><br /></td></tr>
<tr class="separator:a50893b806c98ea8c70518607b4c83b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4a1bba97b58403cdad664895153b29"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a9f4a1bba97b58403cdad664895153b29">getValue</a> (const Key &amp;key, Value &amp;def_value)</td></tr>
<tr class="memdesc:a9f4a1bba97b58403cdad664895153b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-<code>const</code> reference to the value associated with the specified key, or the value given by the second argument if the specified entry does not exist.  <a href="classCDPL_1_1Util_1_1Map.html#a9f4a1bba97b58403cdad664895153b29">More...</a><br /></td></tr>
<tr class="separator:a9f4a1bba97b58403cdad664895153b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa041b9a7b42d192201724dc36c4356bc"><td class="memItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa041b9a7b42d192201724dc36c4356bc">getValue</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:aa041b9a7b42d192201724dc36c4356bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> reference to the value associated with the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#aa041b9a7b42d192201724dc36c4356bc">More...</a><br /></td></tr>
<tr class="separator:aa041b9a7b42d192201724dc36c4356bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca5308dc5a0153f12b185b0c43be975"><td class="memItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#acca5308dc5a0153f12b185b0c43be975">getValue</a> (const Key &amp;key, const Value &amp;def_value) const</td></tr>
<tr class="memdesc:acca5308dc5a0153f12b185b0c43be975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> reference to the value associated with the specified key, or the value given by the second argument if the specified entry does not exist.  <a href="classCDPL_1_1Util_1_1Map.html#acca5308dc5a0153f12b185b0c43be975">More...</a><br /></td></tr>
<tr class="separator:acca5308dc5a0153f12b185b0c43be975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3dc3b60b0b9e1a4445c6d63933632e"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aba3dc3b60b0b9e1a4445c6d63933632e">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:aba3dc3b60b0b9e1a4445c6d63933632e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-<code>const</code> reference to the value associated with the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#aba3dc3b60b0b9e1a4445c6d63933632e">More...</a><br /></td></tr>
<tr class="separator:aba3dc3b60b0b9e1a4445c6d63933632e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4702a2186bdabd433c1c0fa55b8548"><td class="memItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a1c4702a2186bdabd433c1c0fa55b8548">operator[]</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a1c4702a2186bdabd433c1c0fa55b8548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> reference to the value associated with the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#a1c4702a2186bdabd433c1c0fa55b8548">More...</a><br /></td></tr>
<tr class="separator:a1c4702a2186bdabd433c1c0fa55b8548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc9cf0ab12d3e0e8375356103716304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a3dc9cf0ab12d3e0e8375356103716304">removeEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;it)</td></tr>
<tr class="memdesc:a3dc9cf0ab12d3e0e8375356103716304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry pointed to by the iterator <em>it</em> from the map.  <a href="classCDPL_1_1Util_1_1Map.html#a3dc9cf0ab12d3e0e8375356103716304">More...</a><br /></td></tr>
<tr class="separator:a3dc9cf0ab12d3e0e8375356103716304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831683ddbec467a6ccd52c262bba7c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a831683ddbec467a6ccd52c262bba7c2f">removeEntry</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a831683ddbec467a6ccd52c262bba7c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry specified by <em>key</em> from the map.  <a href="classCDPL_1_1Util_1_1Map.html#a831683ddbec467a6ccd52c262bba7c2f">More...</a><br /></td></tr>
<tr class="separator:a831683ddbec467a6ccd52c262bba7c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf3f6f6b7cfaad7888a4bd8347658cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#addf3f6f6b7cfaad7888a4bd8347658cf">removeEntries</a> (const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;first, const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;last)</td></tr>
<tr class="memdesc:addf3f6f6b7cfaad7888a4bd8347658cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries pointed to by the iterators in the range <em>[first, last)</em> from the map.  <a href="classCDPL_1_1Util_1_1Map.html#addf3f6f6b7cfaad7888a4bd8347658cf">More...</a><br /></td></tr>
<tr class="separator:addf3f6f6b7cfaad7888a4bd8347658cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221b1ac4cd836c73c9a48cfd719745f1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a221b1ac4cd836c73c9a48cfd719745f1">insertEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a> &amp;item)</td></tr>
<tr class="memdesc:a221b1ac4cd836c73c9a48cfd719745f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert the key/value pair <em>item</em> into the map.  <a href="classCDPL_1_1Util_1_1Map.html#a221b1ac4cd836c73c9a48cfd719745f1">More...</a><br /></td></tr>
<tr class="separator:a221b1ac4cd836c73c9a48cfd719745f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2353a3d6b9bf7f340b159531b4655f86"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>, <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a2353a3d6b9bf7f340b159531b4655f86">insertEntry</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a2353a3d6b9bf7f340b159531b4655f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert a new entry with specified key and value into the map.  <a href="classCDPL_1_1Util_1_1Map.html#a2353a3d6b9bf7f340b159531b4655f86">More...</a><br /></td></tr>
<tr class="separator:a2353a3d6b9bf7f340b159531b4655f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351b073ed7b4c4736d9382d9dd11f954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a351b073ed7b4c4736d9382d9dd11f954">insertEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;it, const <a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a> &amp;item)</td></tr>
<tr class="memdesc:a351b073ed7b4c4736d9382d9dd11f954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert the key/value pair <em>item</em> into the map and uses the iterator <em>it</em> as a hint for the insertion location.  <a href="classCDPL_1_1Util_1_1Map.html#a351b073ed7b4c4736d9382d9dd11f954">More...</a><br /></td></tr>
<tr class="separator:a351b073ed7b4c4736d9382d9dd11f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d51b17b2e1673c9f8846db8e7b5e8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a34d51b17b2e1673c9f8846db8e7b5e8d">insertEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;it, const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a34d51b17b2e1673c9f8846db8e7b5e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert a new entry with the specified key and value into the map and uses the iterator <em>it</em> as a hint for the insertion location.  <a href="classCDPL_1_1Util_1_1Map.html#a34d51b17b2e1673c9f8846db8e7b5e8d">More...</a><br /></td></tr>
<tr class="separator:a34d51b17b2e1673c9f8846db8e7b5e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3a7139e79868780a3563e27c160a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#acb3a7139e79868780a3563e27c160a7a">setEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a> &amp;item)</td></tr>
<tr class="memdesc:acb3a7139e79868780a3563e27c160a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new entry or updates the value of an existing entry with the key and value given by <em>item</em>.  <a href="classCDPL_1_1Util_1_1Map.html#acb3a7139e79868780a3563e27c160a7a">More...</a><br /></td></tr>
<tr class="separator:acb3a7139e79868780a3563e27c160a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b90aff7e3a0a496aa5e118ef885fb9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a1b90aff7e3a0a496aa5e118ef885fb9c">setEntry</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a1b90aff7e3a0a496aa5e118ef885fb9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new entry or updates the value of an existing entry with the specified key and value.  <a href="classCDPL_1_1Util_1_1Map.html#a1b90aff7e3a0a496aa5e118ef885fb9c">More...</a><br /></td></tr>
<tr class="separator:a1b90aff7e3a0a496aa5e118ef885fb9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb9212f5c5d523365ed997c02543585"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a6bb9212f5c5d523365ed997c02543585"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a6bb9212f5c5d523365ed997c02543585">insertEntries</a> (const InputIter &amp;first, const InputIter &amp;last)</td></tr>
<tr class="memdesc:a6bb9212f5c5d523365ed997c02543585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to insert the key/value pairs in the range <em>[first, last)</em>.  <a href="classCDPL_1_1Util_1_1Map.html#a6bb9212f5c5d523365ed997c02543585">More...</a><br /></td></tr>
<tr class="separator:a6bb9212f5c5d523365ed997c02543585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae103f66d71a73931fdc3eaf6acf664aa"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:ae103f66d71a73931fdc3eaf6acf664aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ae103f66d71a73931fdc3eaf6acf664aa">setEntries</a> (const InputIter &amp;first, const InputIter &amp;last)</td></tr>
<tr class="memdesc:ae103f66d71a73931fdc3eaf6acf664aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entries or updates the value of existing entries using the key/value pairs in the range <em>[first, last)</em>.  <a href="classCDPL_1_1Util_1_1Map.html#ae103f66d71a73931fdc3eaf6acf664aa">More...</a><br /></td></tr>
<tr class="separator:ae103f66d71a73931fdc3eaf6acf664aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4ca45859d984e71787b2fa731ac829"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a1c4ca45859d984e71787b2fa731ac829">getLowerBound</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a1c4ca45859d984e71787b2fa731ac829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the first entry whose key is not less than the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#a1c4ca45859d984e71787b2fa731ac829">More...</a><br /></td></tr>
<tr class="separator:a1c4ca45859d984e71787b2fa731ac829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d0260ce9fadefb727b2aaeb36669c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a759d0260ce9fadefb727b2aaeb36669c">getLowerBound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a759d0260ce9fadefb727b2aaeb36669c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first entry whose key is not less than the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#a759d0260ce9fadefb727b2aaeb36669c">More...</a><br /></td></tr>
<tr class="separator:a759d0260ce9fadefb727b2aaeb36669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65efe76e97fb285515f63ee312fb9bdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a65efe76e97fb285515f63ee312fb9bdb">getUpperBound</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a65efe76e97fb285515f63ee312fb9bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the first entry whose key is greater than the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#a65efe76e97fb285515f63ee312fb9bdb">More...</a><br /></td></tr>
<tr class="separator:a65efe76e97fb285515f63ee312fb9bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88138aac5720d400858d3ef905ef6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac88138aac5720d400858d3ef905ef6ea">getUpperBound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:ac88138aac5720d400858d3ef905ef6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first entry whose key is greater than the specified key.  <a href="classCDPL_1_1Util_1_1Map.html#ac88138aac5720d400858d3ef905ef6ea">More...</a><br /></td></tr>
<tr class="separator:ac88138aac5720d400858d3ef905ef6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb670dc8fcbf1b0c575278e6540289c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a5fb670dc8fcbf1b0c575278e6540289c">getEntriesBegin</a> () const</td></tr>
<tr class="memdesc:a5fb670dc8fcbf1b0c575278e6540289c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a5fb670dc8fcbf1b0c575278e6540289c">More...</a><br /></td></tr>
<tr class="separator:a5fb670dc8fcbf1b0c575278e6540289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387fc4e7c7572b715190bb162613764d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a387fc4e7c7572b715190bb162613764d">getEntriesBegin</a> ()</td></tr>
<tr class="memdesc:a387fc4e7c7572b715190bb162613764d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a387fc4e7c7572b715190bb162613764d">More...</a><br /></td></tr>
<tr class="separator:a387fc4e7c7572b715190bb162613764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87f4dadff92451258e5b703d0142b86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ad87f4dadff92451258e5b703d0142b86">getEntriesEnd</a> () const</td></tr>
<tr class="memdesc:ad87f4dadff92451258e5b703d0142b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1Map.html#ad87f4dadff92451258e5b703d0142b86">More...</a><br /></td></tr>
<tr class="separator:ad87f4dadff92451258e5b703d0142b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7fd2c9242fb9ae41631007aa82d497"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a7a7fd2c9242fb9ae41631007aa82d497">getEntriesEnd</a> ()</td></tr>
<tr class="memdesc:a7a7fd2c9242fb9ae41631007aa82d497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a7a7fd2c9242fb9ae41631007aa82d497">More...</a><br /></td></tr>
<tr class="separator:a7a7fd2c9242fb9ae41631007aa82d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8245dfe98d8c2e2b5731d311ce3e738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac8245dfe98d8c2e2b5731d311ce3e738">begin</a> () const</td></tr>
<tr class="memdesc:ac8245dfe98d8c2e2b5731d311ce3e738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1Map.html#ac8245dfe98d8c2e2b5731d311ce3e738">More...</a><br /></td></tr>
<tr class="separator:ac8245dfe98d8c2e2b5731d311ce3e738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae937fa14c3e05bd3104fd5648cdb4dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ae937fa14c3e05bd3104fd5648cdb4dc5">begin</a> ()</td></tr>
<tr class="memdesc:ae937fa14c3e05bd3104fd5648cdb4dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1Map.html#ae937fa14c3e05bd3104fd5648cdb4dc5">More...</a><br /></td></tr>
<tr class="separator:ae937fa14c3e05bd3104fd5648cdb4dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8791fb8ba5cf30dfa3b1e0d79b5cb24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a8791fb8ba5cf30dfa3b1e0d79b5cb24e">end</a> () const</td></tr>
<tr class="memdesc:a8791fb8ba5cf30dfa3b1e0d79b5cb24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1Map.html#a8791fb8ba5cf30dfa3b1e0d79b5cb24e">More...</a><br /></td></tr>
<tr class="separator:a8791fb8ba5cf30dfa3b1e0d79b5cb24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa970d8adc1f77499a0cf43c183e25789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa970d8adc1f77499a0cf43c183e25789">end</a> ()</td></tr>
<tr class="memdesc:aa970d8adc1f77499a0cf43c183e25789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1Map.html#aa970d8adc1f77499a0cf43c183e25789">More...</a><br /></td></tr>
<tr class="separator:aa970d8adc1f77499a0cf43c183e25789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ae67ee4e4df50a0a7645306229b4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">ConstReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ab7ae67ee4e4df50a0a7645306229b4e3">getEntriesReverseBegin</a> () const</td></tr>
<tr class="memdesc:ab7ae67ee4e4df50a0a7645306229b4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the reversed map.  <a href="classCDPL_1_1Util_1_1Map.html#ab7ae67ee4e4df50a0a7645306229b4e3">More...</a><br /></td></tr>
<tr class="separator:ab7ae67ee4e4df50a0a7645306229b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751768c06d1305488e987725c4b4fef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">ReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a751768c06d1305488e987725c4b4fef5">getEntriesReverseBegin</a> ()</td></tr>
<tr class="memdesc:a751768c06d1305488e987725c4b4fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the beginning of the reversed map.  <a href="classCDPL_1_1Util_1_1Map.html#a751768c06d1305488e987725c4b4fef5">More...</a><br /></td></tr>
<tr class="separator:a751768c06d1305488e987725c4b4fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cfeb06d94dc035583cbfbdc4895885"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">ConstReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#ad8cfeb06d94dc035583cbfbdc4895885">getEntriesReverseEnd</a> () const</td></tr>
<tr class="memdesc:ad8cfeb06d94dc035583cbfbdc4895885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the reversed map.  <a href="classCDPL_1_1Util_1_1Map.html#ad8cfeb06d94dc035583cbfbdc4895885">More...</a><br /></td></tr>
<tr class="separator:ad8cfeb06d94dc035583cbfbdc4895885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f926c40c1becff43f1185522561cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">ReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a925f926c40c1becff43f1185522561cc">getEntriesReverseEnd</a> ()</td></tr>
<tr class="memdesc:a925f926c40c1becff43f1185522561cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the end of the reversed map.  <a href="classCDPL_1_1Util_1_1Map.html#a925f926c40c1becff43f1185522561cc">More...</a><br /></td></tr>
<tr class="separator:a925f926c40c1becff43f1185522561cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a2b96cac04740d60da3ffd0e0efc1986c"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1Map.html#a2b96cac04740d60da3ffd0e0efc1986c">getClassName</a> () const</td></tr>
<tr class="memdesc:a2b96cac04740d60da3ffd0e0efc1986c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the (derived) <a class="el" href="classCDPL_1_1Util_1_1Map.html" title="A unique sorted associative container that maps keys to values.">Map</a> class.  <a href="classCDPL_1_1Util_1_1Map.html#a2b96cac04740d60da3ffd0e0efc1986c">More...</a><br /></td></tr>
<tr class="separator:a2b96cac04740d60da3ffd0e0efc1986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, bool AllowDefValues = false, typename KeyCompFunc = std::less&lt;Key&gt;&gt;<br />
class CDPL::Util::Map&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;</h3>

<p>A unique sorted associative container that maps keys to values. </p>
<p>Since <code>Map</code> is a sorted associative container, it uses an ordering relation on its keys. Two keys are considered to be equivalent if neither one is less than the other. <code>Map</code> guarantees that the complexity for most operations is never worse than logarithmic, and the entries are always sorted in ascending order by key. It is also an unique associative container, meaning that no two entries have the same key. <code>Map</code> has the important property that inserting a new entry does not invalidate iterators that point to existing entries. Erasing an entry also does not invalidate any iterators, except, of course, for iterators that actually point to the entry that is being erased.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the map's keys. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the mapped values. </td></tr>
    <tr><td class="paramname">AllowDefValues</td><td>Whether to return a default value or to throw an exception if a key/value entry is not present in the map. </td></tr>
    <tr><td class="paramname">KeyCompFunc</td><td>The type of a functor class used to establish the strictly weak ordering on the map's keys. The functor has to return <code>true</code> if the first argument is less than the second one, and <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ada44e9cb54ee57510561f1a554a6fc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada44e9cb54ee57510561f1a554a6fc3b">&#9670;&nbsp;</a></span>SharedPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a>&gt; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ada44e9cb54ee57510561f1a554a6fc3b">SharedPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reference-counted smart pointer [<a class="el" href="References.html#SHPTR">SHPTR</a>] for dynamically allocated <code>Map</code> instances. </p>

</div>
</div>
<a id="addaee5a359ae386ddd06f97f40aa71e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaee5a359ae386ddd06f97f40aa71e7">&#9670;&nbsp;</a></span>KeyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#addaee5a359ae386ddd06f97f40aa71e7">KeyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the map's keys. </p>

</div>
</div>
<a id="ae8a734bb4066ae9a834ac63ebb45189b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a734bb4066ae9a834ac63ebb45189b">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Value <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ae8a734bb4066ae9a834ac63ebb45189b">ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the mapped values. </p>

</div>
</div>
<a id="af108ab96e5d3d20fdde0bcd82fecfc4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af108ab96e5d3d20fdde0bcd82fecfc4b">&#9670;&nbsp;</a></span>Entry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::value_type <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the key/value pairs stored in the map. </p>
<p>The member <code>Entry::first</code> is the <code>const</code> key object of type <em>Key</em> and the member <code>Entry::second</code> is the associated value object of type <em>Value</em>. </p>

</div>
</div>
<a id="a765d6d413c29bf0f67aac146ac0b5c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765d6d413c29bf0f67aac146ac0b5c80">&#9670;&nbsp;</a></span>ConstEntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::const_iterator <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant iterator used to iterate over the entries of the map. </p>

</div>
</div>
<a id="a710aa3a01de9ae9a820ddd5b6d6d8170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710aa3a01de9ae9a820ddd5b6d6d8170">&#9670;&nbsp;</a></span>ConstReverseEntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::const_reverse_iterator <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">ConstReverseEntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant iterator used to iterate backwards over the entries of the map. </p>

</div>
</div>
<a id="ac699e0163375658aceffd56546fbfe71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac699e0163375658aceffd56546fbfe71">&#9670;&nbsp;</a></span>EntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::iterator <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutable iterator used to iterate over the entries of the map. </p>

</div>
</div>
<a id="aa20a40e0f2eb72335a94ea38997f2d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20a40e0f2eb72335a94ea38997f2d4b">&#9670;&nbsp;</a></span>ReverseEntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::reverse_iterator <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">ReverseEntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutable iterator used to iterate backwards over the entries of the map. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa053665919da1172b8a006ebff526a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa053665919da1172b8a006ebff526a84">&#9670;&nbsp;</a></span>Map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty map. </p>

</div>
</div>
<a id="aa81fbb6d964c954135e9002728593215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81fbb6d964c954135e9002728593215">&#9670;&nbsp;</a></span>Map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyCompFunc &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty map and uses <em>func</em> as key compare function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The key compare function to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a822a4accdced3373f1ecc10f817646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a822a4accdced3373f1ecc10f817646">&#9670;&nbsp;</a></span>Map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb8d41c3b2e4555eaa14b8a77c8cd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb8d41c3b2e4555eaa14b8a77c8cd5a">&#9670;&nbsp;</a></span>Map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyCompFunc &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em> and uses <em>func</em> as key compare function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
    <tr><td class="paramname">func</td><td>The key compare function to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc9680c51f3f3ef479e250f95e4ad77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9680c51f3f3ef479e250f95e4ad77e">&#9670;&nbsp;</a></span>~Map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::~<a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6247c4e24f849dbc9e6295c67eaeaa72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6247c4e24f849dbc9e6295c67eaeaa72">&#9670;&nbsp;</a></span>getData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::StorageType &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9cda1c602e3f8effdb0511ae39429bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cda1c602e3f8effdb0511ae39429bc5">&#9670;&nbsp;</a></span>getData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::StorageType &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ba1b9320cc99543cf78d41b13961f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba1b9320cc99543cf78d41b13961f25">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size (number of entries) of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the map. </dd></dl>

</div>
</div>
<a id="a625e5c2869343b56855cfc8da352ca1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625e5c2869343b56855cfc8da352ca1a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::isEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the map is empty (<code><a class="el" href="classCDPL_1_1Util_1_1Map.html#a3ba1b9320cc99543cf78d41b13961f25" title="Returns the size (number of entries) of the map.">getSize()</a> == 0</code>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the map is empty, and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="ab24a27ce1b3e781f6b8e66c5b4d056dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24a27ce1b3e781f6b8e66c5b4d056dd">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all entries. </p>

</div>
</div>
<a id="a82a335f3768380a772b2b9ff77cebbed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a335f3768380a772b2b9ff77cebbed">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCDPL_1_1Util_1_1Map.html">Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents with <em>map</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The other map with which the contents will be exchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25b19a09b4296cea075d8809539ec635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b19a09b4296cea075d8809539ec635">&#9670;&nbsp;</a></span>getKeyCompareFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KeyCompFunc <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getKeyCompareFunction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the key compare function used by the map. </p>
<dl class="section return"><dt>Returns</dt><dd>The key compare function. </dd></dl>

</div>
</div>
<a id="a8ae18e922e17d653c9599e71cea6eab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae18e922e17d653c9599e71cea6eab9">&#9670;&nbsp;</a></span>getEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the entry specified by <em>key</em>. </p>
<p>If the map does not contain an entry with the specified key, an iterator pointing one past the last entry of the map (<code>== <a class="el" href="classCDPL_1_1Util_1_1Map.html#a7a7fd2c9242fb9ae41631007aa82d497" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a></code>) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing the entry specified by the key or <a class="el" href="classCDPL_1_1Util_1_1Map.html#a7a7fd2c9242fb9ae41631007aa82d497" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a>, if the map contains no such entry. </dd></dl>

</div>
</div>
<a id="affed934d03788fef1750d8a4296dfed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed934d03788fef1750d8a4296dfed8">&#9670;&nbsp;</a></span>getEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the entry specified by <em>key</em>. </p>
<p>If the map does not contain an entry with the specified key, an iterator pointing one past the last entry of the map (<code>== <a class="el" href="classCDPL_1_1Util_1_1Map.html#a7a7fd2c9242fb9ae41631007aa82d497" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a></code>) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing the entry specified by the key or <a class="el" href="classCDPL_1_1Util_1_1Map.html#a7a7fd2c9242fb9ae41631007aa82d497" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a>, if the map contains no such entry. </dd></dl>

</div>
</div>
<a id="aa0cbee71d8e0a18549e4a89e100ed9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cbee71d8e0a18549e4a89e100ed9bb">&#9670;&nbsp;</a></span>containsEntry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::containsEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the map contains an entry with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the map contains the specified entry, and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a50893b806c98ea8c70518607b4c83b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50893b806c98ea8c70518607b4c83b24">&#9670;&nbsp;</a></span>getValue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-<code>const</code> reference to the value associated with the specified key. </p>
<p>If the map contains an entry with the specified key, a reference to the associated value is returned. If the map does not contain the entry and default values are enabled (that is, the template parameter <em>AllowDefValues</em> is <code>true</code>), a new map entry is created which associates <em>key</em> with the default constructed value object. Otherwise, <a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a> is thrown to indicate the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-<code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f4a1bba97b58403cdad664895153b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4a1bba97b58403cdad664895153b29">&#9670;&nbsp;</a></span>getValue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>def_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-<code>const</code> reference to the value associated with the specified key, or the value given by the second argument if the specified entry does not exist. </p>
<p>If the map contains an entry with the specified key, a reference to the associated value is returned. If the map does not contain the entry, the second argument <em>def_value</em> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
    <tr><td class="paramname">def_value</td><td>The value which is returned if the specified entry does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-<code>const</code> reference to the requested or default value. </dd></dl>

</div>
</div>
<a id="aa041b9a7b42d192201724dc36c4356bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa041b9a7b42d192201724dc36c4356bc">&#9670;&nbsp;</a></span>getValue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> reference to the value associated with the specified key. </p>
<p>If the map contains the specified entry, a reference to the associated value is returned. If the map does not contain the entry and default values are enabled (that is, the template parameter <em>AllowDefValues</em> is <code>true</code>), a <code>const</code> reference to a default constructed value object is returned. Otherwise, <a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a> is thrown to indicate the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca5308dc5a0153f12b185b0c43be975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca5308dc5a0153f12b185b0c43be975">&#9670;&nbsp;</a></span>getValue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>def_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> reference to the value associated with the specified key, or the value given by the second argument if the specified entry does not exist. </p>
<p>If the map contains an entry with the specified key, a reference to the associated value is returned. If the map does not contain the entry, the second argument <em>def_value</em> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
    <tr><td class="paramname">def_value</td><td>The value which is returned if the specified entry does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to the requested or default value. </dd></dl>

</div>
</div>
<a id="aba3dc3b60b0b9e1a4445c6d63933632e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3dc3b60b0b9e1a4445c6d63933632e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-<code>const</code> reference to the value associated with the specified key. </p>
<p>The method is equivalent to <a class="el" href="classCDPL_1_1Util_1_1Map.html#a50893b806c98ea8c70518607b4c83b24" title="Returns a non-const reference to the value associated with the specified key.">getValue(const Key&amp;)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-<code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1Map.html#a50893b806c98ea8c70518607b4c83b24" title="Returns a non-const reference to the value associated with the specified key.">getValue(const Key&amp;)</a> </dd></dl>

</div>
</div>
<a id="a1c4702a2186bdabd433c1c0fa55b8548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4702a2186bdabd433c1c0fa55b8548">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value &amp; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> reference to the value associated with the specified key. </p>
<p>The method is equivalent to <a class="el" href="classCDPL_1_1Util_1_1Map.html#aa041b9a7b42d192201724dc36c4356bc" title="Returns a const reference to the value associated with the specified key.">getValue(const Key&amp;) const</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1Map.html#aa041b9a7b42d192201724dc36c4356bc" title="Returns a const reference to the value associated with the specified key.">getValue(const Key&amp;) const</a> </dd></dl>

</div>
</div>
<a id="a3dc9cf0ab12d3e0e8375356103716304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc9cf0ab12d3e0e8375356103716304">&#9670;&nbsp;</a></span>removeEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entry pointed to by the iterator <em>it</em> from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator pointing to the entry to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a831683ddbec467a6ccd52c262bba7c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a831683ddbec467a6ccd52c262bba7c2f">&#9670;&nbsp;</a></span>removeEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entry specified by <em>key</em> from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf3f6f6b7cfaad7888a4bd8347658cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf3f6f6b7cfaad7888a4bd8347658cf">&#9670;&nbsp;</a></span>removeEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all entries pointed to by the iterators in the range <em>[first, last)</em> from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a221b1ac4cd836c73c9a48cfd719745f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221b1ac4cd836c73c9a48cfd719745f1">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert the key/value pair <em>item</em> into the map. </p>
<p>Inserts <em>item</em> if and only if the map does not already contain an entry whose key is the same as the key of <em>item</em>. The return value is a pair <code>P</code>. <code>P.first</code> is an iterator pointing to the entry whose key is the same as the key of <em>item</em>. <code>P.second</code> is a boolean value which is <code>true</code> if <em>item</em> was actually inserted, and <code>false</code> if the map already contained an entry with the same key as <em>item</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The key/value pair to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair consisting of an iterator pointing to an entry whose key is the same as the key of <em>item</em> and a boolean value which is <code>true</code> if the insertion of <em>item</em> was successful (an entry with the specified key did not already exist), and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a2353a3d6b9bf7f340b159531b4655f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2353a3d6b9bf7f340b159531b4655f86">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a>, <a class="el" href="classbool.html">bool</a> &gt; <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert a new entry with specified key and value into the map. </p>
<p>Inserts a new entry if and only if the map does not already contain an entry whose key is the same as the specified key. The return value is a pair <code>P</code>. <code>P.first</code> is an iterator pointing to the entry whose key is the same as the specified key. <code>P.second</code> is a boolean value which is <code>true</code> if <em>item</em> was actually inserted, and <code>false</code> if the map already contained an entry with the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A std::pair consisting of an iterator pointing to an entry whose key is the same as <em>key</em> and a boolean value, which is <code>true</code> if the insertion of <em>item</em> was successful (an entry with the specified key did not already exist), and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a351b073ed7b4c4736d9382d9dd11f954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351b073ed7b4c4736d9382d9dd11f954">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert the key/value pair <em>item</em> into the map and uses the iterator <em>it</em> as a hint for the insertion location. </p>
<p>Inserts <em>item</em> if and only if the map does not already contain an entry whose key is the same as the key of <em>item</em>. The argument <em>it</em> is a hint and points to the location where the insertion position search will begin. The return value is a dereferenceable iterator that points to the entry with a key that is equivalent to that of <em>item</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator pointing to a location where the insertion position search will begin. </td></tr>
    <tr><td class="paramname">item</td><td>The key/value pair to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the entry with a key that is equivalent to that of <em>item</em>. </dd></dl>

</div>
</div>
<a id="a34d51b17b2e1673c9f8846db8e7b5e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d51b17b2e1673c9f8846db8e7b5e8d">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert a new entry with the specified key and value into the map and uses the iterator <em>it</em> as a hint for the insertion location. </p>
<p>Inserts a new entry if and only if the map does not already contain an entry whose key is the same as the specified key. The argument <em>it</em> is a hint and points to the location where the insertion position search will begin. The return value is a dereferenceable iterator that points to the entry with a key that is equivalent to the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator pointing to a location where the insertion position search will begin. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the entry to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with <em>key</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the entry with a key that is equivalent to the specified key. </dd></dl>

</div>
</div>
<a id="acb3a7139e79868780a3563e27c160a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3a7139e79868780a3563e27c160a7a">&#9670;&nbsp;</a></span>setEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::setEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1Map.html#af108ab96e5d3d20fdde0bcd82fecfc4b">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new entry or updates the value of an existing entry with the key and value given by <em>item</em>. </p>
<p>If the map does not already contain an entry whose key is the same as the key of <em>item</em> then a new entry will be created. Otherwise, the value of the existing entry is updated with the value of <em>item</em>. The return value is a dereferenceable iterator that points to the newly inserted or updated entry whose key is equivalent to that of <em>item</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The key/value pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted or updated entry. </dd></dl>

</div>
</div>
<a id="a1b90aff7e3a0a496aa5e118ef885fb9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b90aff7e3a0a496aa5e118ef885fb9c">&#9670;&nbsp;</a></span>setEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::setEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new entry or updates the value of an existing entry with the specified key and value. </p>
<p>If the map does not already contain an entry whose key is the same as <em>key</em> then a new entry will be created. Otherwise, the value of the existing entry is updated with <em>value</em>. The return value is a dereferenceable iterator that points to the newly inserted or updated entry whose key is equivalent to the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry to insert or update. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be associated with <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the newly inserted or updated entry. </dd></dl>

</div>
</div>
<a id="a6bb9212f5c5d523365ed997c02543585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb9212f5c5d523365ed997c02543585">&#9670;&nbsp;</a></span>insertEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntries </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to insert the key/value pairs in the range <em>[first, last)</em>. </p>
<p>This is equivalent to calling <a class="el" href="classCDPL_1_1Util_1_1Map.html#a221b1ac4cd836c73c9a48cfd719745f1" title="Tries to insert the key/value pair item into the map.">insertEntry(const Entry&amp;)</a> for each key/value pair <em>i</em> that is pointed to by an iterator in the range <em>[first, last)</em>. A key/value pair is inserted if and only if the map does not already contain an entry with an equivalent key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae103f66d71a73931fdc3eaf6acf664aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae103f66d71a73931fdc3eaf6acf664aa">&#9670;&nbsp;</a></span>setEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::setEntries </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts new entries or updates the value of existing entries using the key/value pairs in the range <em>[first, last)</em>. </p>
<p>This is equivalent to calling <a class="el" href="classCDPL_1_1Util_1_1Map.html#acb3a7139e79868780a3563e27c160a7a" title="Inserts a new entry or updates the value of an existing entry with the key and value given by item.">setEntry(const Entry&amp;)</a> for each key/value pair <em>i</em> that is pointed to by an iterator in the range <em>[first, last)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c4ca45859d984e71787b2fa731ac829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4ca45859d984e71787b2fa731ac829">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getLowerBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the first entry whose key is not less than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the first entry whose key is not less than the specified key. </dd></dl>

</div>
</div>
<a id="a759d0260ce9fadefb727b2aaeb36669c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759d0260ce9fadefb727b2aaeb36669c">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getLowerBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first entry whose key is not less than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the first entry whose key is not less than the specified key. </dd></dl>

</div>
</div>
<a id="a65efe76e97fb285515f63ee312fb9bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65efe76e97fb285515f63ee312fb9bdb">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getUpperBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the first entry whose key is greater than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the first entry whose key is greater than the specified key. </dd></dl>

</div>
</div>
<a id="ac88138aac5720d400858d3ef905ef6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88138aac5720d400858d3ef905ef6ea">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getUpperBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first entry whose key is greater than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the first entry whose key is greater than the specified key. </dd></dl>

</div>
</div>
<a id="a5fb670dc8fcbf1b0c575278e6540289c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb670dc8fcbf1b0c575278e6540289c">&#9670;&nbsp;</a></span>getEntriesBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="a387fc4e7c7572b715190bb162613764d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387fc4e7c7572b715190bb162613764d">&#9670;&nbsp;</a></span>getEntriesBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="ad87f4dadff92451258e5b703d0142b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad87f4dadff92451258e5b703d0142b86">&#9670;&nbsp;</a></span>getEntriesEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="a7a7fd2c9242fb9ae41631007aa82d497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7fd2c9242fb9ae41631007aa82d497">&#9670;&nbsp;</a></span>getEntriesEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="ac8245dfe98d8c2e2b5731d311ce3e738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8245dfe98d8c2e2b5731d311ce3e738">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="ae937fa14c3e05bd3104fd5648cdb4dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae937fa14c3e05bd3104fd5648cdb4dc5">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="a8791fb8ba5cf30dfa3b1e0d79b5cb24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8791fb8ba5cf30dfa3b1e0d79b5cb24e">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a765d6d413c29bf0f67aac146ac0b5c80">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="aa970d8adc1f77499a0cf43c183e25789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa970d8adc1f77499a0cf43c183e25789">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#ac699e0163375658aceffd56546fbfe71">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="ab7ae67ee4e4df50a0a7645306229b4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ae67ee4e4df50a0a7645306229b4e3">&#9670;&nbsp;</a></span>getEntriesReverseBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">ConstReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the reversed map. </dd></dl>

</div>
</div>
<a id="a751768c06d1305488e987725c4b4fef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751768c06d1305488e987725c4b4fef5">&#9670;&nbsp;</a></span>getEntriesReverseBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">ReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the beginning of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the beginning of the reversed map. </dd></dl>

</div>
</div>
<a id="ad8cfeb06d94dc035583cbfbdc4895885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cfeb06d94dc035583cbfbdc4895885">&#9670;&nbsp;</a></span>getEntriesReverseEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#a710aa3a01de9ae9a820ddd5b6d6d8170">ConstReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the reversed map. </dd></dl>

</div>
</div>
<a id="a925f926c40c1becff43f1185522561cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f926c40c1becff43f1185522561cc">&#9670;&nbsp;</a></span>getEntriesReverseEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1Map.html#aa20a40e0f2eb72335a94ea38997f2d4b">ReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the end of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the end of the reversed map. </dd></dl>

</div>
</div>
<a id="a2b96cac04740d60da3ffd0e0efc1986c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b96cac04740d60da3ffd0e0efc1986c">&#9670;&nbsp;</a></span>getClassName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getClassName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the (derived) <a class="el" href="classCDPL_1_1Util_1_1Map.html" title="A unique sorted associative container that maps keys to values.">Map</a> class. </p>
<p>Overriding this method provides an easy way to customize exception messages with the name of a derived class.</p>
<p>Consider the class <code>MyMap</code> which inherits publicly from <code>Map&lt;int, int&gt;</code> and overrides <a class="el" href="classCDPL_1_1Util_1_1Map.html#a2b96cac04740d60da3ffd0e0efc1986c" title="Returns the name of the (derived) Map class.">getClassName()</a>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>MyMap : <span class="keyword">public</span> <a class="code" href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a>&lt;int, int&gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">   .....</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classCDPL_1_1Util_1_1Map.html#a2b96cac04740d60da3ffd0e0efc1986c">getClassName</a>()<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyMap&quot;</span>;</div>
<div class="line">   }</div>
<div class="line">};</div>
<div class="ttc" id="aclassCDPL_1_1Util_1_1Map_html"><div class="ttname"><a href="classCDPL_1_1Util_1_1Map.html">CDPL::Util::Map</a></div><div class="ttdoc">A unique sorted associative container that maps keys to values.</div><div class="ttdef"><b>Definition:</b> Map.hpp:96</div></div>
<div class="ttc" id="aclassCDPL_1_1Util_1_1Map_html_a2b96cac04740d60da3ffd0e0efc1986c"><div class="ttname"><a href="classCDPL_1_1Util_1_1Map.html#a2b96cac04740d60da3ffd0e0efc1986c">CDPL::Util::Map::getClassName</a></div><div class="ttdeci">virtual const char * getClassName() const</div><div class="ttdoc">Returns the name of the (derived) Map class.</div><div class="ttdef"><b>Definition:</b> Map.hpp:1014</div></div>
</div><!-- fragment --><p>If, for example, the requested value for a particular key is not found, the error message of the thrown <a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a> exception will now start with "MyMap: ...." instead of the default "Map: ....".</p>
<dl class="section return"><dt>Returns</dt><dd>The name of the class as a C-string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1Array.html#a0f8a06b8703c4519b8c400620ba4a9b1" title="Returns the name of the (derived) array class.">Array::getClassName</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Map_8hpp_source.html">Map.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
