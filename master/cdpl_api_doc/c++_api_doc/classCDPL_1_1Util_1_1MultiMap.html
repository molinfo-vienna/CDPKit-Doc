<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chemical Data Processing Library C++ API - Version 1.1.0: CDPL::Util::MultiMap&lt; Key, Value, AllowDefValues, KeyCompFunc &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/NativeMML"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Chemical Data Processing Library C++ API - Version 1.1.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceCDPL.html">CDPL</a></li><li class="navelem"><a class="el" href="namespaceCDPL_1_1Util.html">Util</a></li><li class="navelem"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classCDPL_1_1Util_1_1MultiMap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CDPL::Util::MultiMap&lt; Key, Value, AllowDefValues, KeyCompFunc &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A multiple sorted associative container that maps keys to values.  
 <a href="classCDPL_1_1Util_1_1MultiMap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MultiMap_8hpp_source.html">MultiMap.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for CDPL::Util::MultiMap&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="classCDPL_1_1Util_1_1MultiMap__inherit__graph.svg" width="100%" height="530"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abbdc152b629c0f1b506f2859e3d295a0"><td class="memItemLeft" align="right" valign="top">typedef std::shared_ptr&lt; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#abbdc152b629c0f1b506f2859e3d295a0">SharedPointer</a></td></tr>
<tr class="memdesc:abbdc152b629c0f1b506f2859e3d295a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference-counted smart pointer [<a class="el" href="References.html#SHPTR">SHPTR</a>] for dynamically allocated <code>MultiMap</code> instances.  <a href="classCDPL_1_1Util_1_1MultiMap.html#abbdc152b629c0f1b506f2859e3d295a0">More...</a><br /></td></tr>
<tr class="separator:abbdc152b629c0f1b506f2859e3d295a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025e4ca5a7cfa6ee0120e40d00a6cc3e"><td class="memItemLeft" align="right" valign="top">typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a025e4ca5a7cfa6ee0120e40d00a6cc3e">KeyType</a></td></tr>
<tr class="memdesc:a025e4ca5a7cfa6ee0120e40d00a6cc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map's keys.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a025e4ca5a7cfa6ee0120e40d00a6cc3e">More...</a><br /></td></tr>
<tr class="separator:a025e4ca5a7cfa6ee0120e40d00a6cc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f0735582440d53401c6a2f1249b97"><td class="memItemLeft" align="right" valign="top">typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a915f0735582440d53401c6a2f1249b97">ValueType</a></td></tr>
<tr class="memdesc:a915f0735582440d53401c6a2f1249b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the mapped values.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a915f0735582440d53401c6a2f1249b97">More...</a><br /></td></tr>
<tr class="separator:a915f0735582440d53401c6a2f1249b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e6d586b69b95ce009e2b1f6d48bc2a"><td class="memItemLeft" align="right" valign="top">typedef StorageType::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a></td></tr>
<tr class="memdesc:a84e6d586b69b95ce009e2b1f6d48bc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the key/value pairs stored in the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">More...</a><br /></td></tr>
<tr class="separator:a84e6d586b69b95ce009e2b1f6d48bc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21868fcca73931bf7b0adf68536bf9e"><td class="memItemLeft" align="right" valign="top">typedef StorageType::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a></td></tr>
<tr class="memdesc:af21868fcca73931bf7b0adf68536bf9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator used to iterate over the entries of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">More...</a><br /></td></tr>
<tr class="separator:af21868fcca73931bf7b0adf68536bf9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0da389f14ea618b999767781b2a80ae"><td class="memItemLeft" align="right" valign="top">typedef StorageType::const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">ConstReverseEntryIterator</a></td></tr>
<tr class="memdesc:ab0da389f14ea618b999767781b2a80ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant iterator used to iterate backwards over the entries of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">More...</a><br /></td></tr>
<tr class="separator:ab0da389f14ea618b999767781b2a80ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dcf6383707ea2a3e7bac0fc1ca00b6"><td class="memItemLeft" align="right" valign="top">typedef StorageType::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a></td></tr>
<tr class="memdesc:a37dcf6383707ea2a3e7bac0fc1ca00b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable iterator used to iterate over the entries of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">More...</a><br /></td></tr>
<tr class="separator:a37dcf6383707ea2a3e7bac0fc1ca00b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae60fa415108ceef98a742838310084"><td class="memItemLeft" align="right" valign="top">typedef StorageType::reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">ReverseEntryIterator</a></td></tr>
<tr class="memdesc:adae60fa415108ceef98a742838310084"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable iterator used to iterate backwards over the entries of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">More...</a><br /></td></tr>
<tr class="separator:adae60fa415108ceef98a742838310084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f40f0fec5642f1ccb553247a48479c9"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>, <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a1f40f0fec5642f1ccb553247a48479c9">EntryIteratorRange</a></td></tr>
<tr class="memdesc:a1f40f0fec5642f1ccb553247a48479c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of mutable iterators used to specify the start and end of a range of entries.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a1f40f0fec5642f1ccb553247a48479c9">More...</a><br /></td></tr>
<tr class="separator:a1f40f0fec5642f1ccb553247a48479c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b9860b1b0f8137f048259e5f69e73e"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>, <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a94b9860b1b0f8137f048259e5f69e73e">ConstEntryIteratorRange</a></td></tr>
<tr class="memdesc:a94b9860b1b0f8137f048259e5f69e73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pair of constant iterators used to specify the start and end of a range of entries.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a94b9860b1b0f8137f048259e5f69e73e">More...</a><br /></td></tr>
<tr class="separator:a94b9860b1b0f8137f048259e5f69e73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f751dfd19cb5d6d24c797e5a7ab7d1a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a8f751dfd19cb5d6d24c797e5a7ab7d1a">MultiMap</a> ()</td></tr>
<tr class="memdesc:a8f751dfd19cb5d6d24c797e5a7ab7d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a8f751dfd19cb5d6d24c797e5a7ab7d1a">More...</a><br /></td></tr>
<tr class="separator:a8f751dfd19cb5d6d24c797e5a7ab7d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3194f5f85d17d25ff4964d78c9a37d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a8a3194f5f85d17d25ff4964d78c9a37d">MultiMap</a> (const KeyCompFunc &amp;func)</td></tr>
<tr class="memdesc:a8a3194f5f85d17d25ff4964d78c9a37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty map and uses <em>func</em> as key compare function.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a8a3194f5f85d17d25ff4964d78c9a37d">More...</a><br /></td></tr>
<tr class="separator:a8a3194f5f85d17d25ff4964d78c9a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60276ae584ab2f96ce56edec39eeca6b"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a60276ae584ab2f96ce56edec39eeca6b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a60276ae584ab2f96ce56edec39eeca6b">MultiMap</a> (const InputIter &amp;first, const InputIter &amp;last)</td></tr>
<tr class="memdesc:a60276ae584ab2f96ce56edec39eeca6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em>.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a60276ae584ab2f96ce56edec39eeca6b">More...</a><br /></td></tr>
<tr class="separator:a60276ae584ab2f96ce56edec39eeca6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99a0d33a7bfdd4c0604ad929d3ad379"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:ab99a0d33a7bfdd4c0604ad929d3ad379"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab99a0d33a7bfdd4c0604ad929d3ad379">MultiMap</a> (const InputIter &amp;first, const InputIter &amp;last, const KeyCompFunc &amp;func)</td></tr>
<tr class="memdesc:ab99a0d33a7bfdd4c0604ad929d3ad379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em> and uses <em>func</em> as key compare function.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ab99a0d33a7bfdd4c0604ad929d3ad379">More...</a><br /></td></tr>
<tr class="separator:ab99a0d33a7bfdd4c0604ad929d3ad379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21140bda55d77f60146aac3e1bdfb27b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a21140bda55d77f60146aac3e1bdfb27b">~MultiMap</a> ()</td></tr>
<tr class="memdesc:a21140bda55d77f60146aac3e1bdfb27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a21140bda55d77f60146aac3e1bdfb27b">More...</a><br /></td></tr>
<tr class="separator:a21140bda55d77f60146aac3e1bdfb27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71eed20cfa07a80953c863696a8fa46"><td class="memItemLeft" align="right" valign="top">StorageType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#aa71eed20cfa07a80953c863696a8fa46">getData</a> ()</td></tr>
<tr class="separator:aa71eed20cfa07a80953c863696a8fa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364cf4bd6e43bce343f1622b54ab8c51"><td class="memItemLeft" align="right" valign="top">const StorageType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a364cf4bd6e43bce343f1622b54ab8c51">getData</a> () const</td></tr>
<tr class="separator:a364cf4bd6e43bce343f1622b54ab8c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6a048a8bcb3bb9a60430b292d528b2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a9a6a048a8bcb3bb9a60430b292d528b2">getSize</a> () const</td></tr>
<tr class="memdesc:a9a6a048a8bcb3bb9a60430b292d528b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of entries) of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a9a6a048a8bcb3bb9a60430b292d528b2">More...</a><br /></td></tr>
<tr class="separator:a9a6a048a8bcb3bb9a60430b292d528b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2ea618effd04f9eb552e85977a36b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#aca2ea618effd04f9eb552e85977a36b8">isEmpty</a> () const</td></tr>
<tr class="memdesc:aca2ea618effd04f9eb552e85977a36b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the map is empty (<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a9a6a048a8bcb3bb9a60430b292d528b2" title="Returns the size (number of entries) of the map.">getSize()</a> == 0).  <a href="classCDPL_1_1Util_1_1MultiMap.html#aca2ea618effd04f9eb552e85977a36b8">More...</a><br /></td></tr>
<tr class="separator:aca2ea618effd04f9eb552e85977a36b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f9134ed1f3751f7aabfcec180d4dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af4f9134ed1f3751f7aabfcec180d4dc6">clear</a> ()</td></tr>
<tr class="memdesc:af4f9134ed1f3751f7aabfcec180d4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases all entries.  <a href="classCDPL_1_1Util_1_1MultiMap.html#af4f9134ed1f3751f7aabfcec180d4dc6">More...</a><br /></td></tr>
<tr class="separator:af4f9134ed1f3751f7aabfcec180d4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e4f4f8316da24915ca781a0b09a5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a05e4f4f8316da24915ca781a0b09a5f9">swap</a> (<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> &amp;map)</td></tr>
<tr class="memdesc:a05e4f4f8316da24915ca781a0b09a5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents with <em>map</em>.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a05e4f4f8316da24915ca781a0b09a5f9">More...</a><br /></td></tr>
<tr class="separator:a05e4f4f8316da24915ca781a0b09a5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59878b6ac823d2533922eb411f64d86"><td class="memItemLeft" align="right" valign="top">KeyCompFunc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ac59878b6ac823d2533922eb411f64d86">getKeyCompareFunction</a> () const</td></tr>
<tr class="memdesc:ac59878b6ac823d2533922eb411f64d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key compare function used by the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ac59878b6ac823d2533922eb411f64d86">More...</a><br /></td></tr>
<tr class="separator:ac59878b6ac823d2533922eb411f64d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b4ec5108fe3ccb0164ab226c1ea30a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a55b4ec5108fe3ccb0164ab226c1ea30a">getNumEntries</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a55b4ec5108fe3ccb0164ab226c1ea30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a55b4ec5108fe3ccb0164ab226c1ea30a">More...</a><br /></td></tr>
<tr class="separator:a55b4ec5108fe3ccb0164ab226c1ea30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b020b1d68b64314f850d362b46c8f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a1f40f0fec5642f1ccb553247a48479c9">EntryIteratorRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ac7b020b1d68b64314f850d362b46c8f9">getEntries</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:ac7b020b1d68b64314f850d362b46c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounds of a range that includes all entries with a key that compares equal to the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ac7b020b1d68b64314f850d362b46c8f9">More...</a><br /></td></tr>
<tr class="separator:ac7b020b1d68b64314f850d362b46c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffc35e18cf3c1ecd25b47dafd869b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a94b9860b1b0f8137f048259e5f69e73e">ConstEntryIteratorRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#aaffc35e18cf3c1ecd25b47dafd869b8f">getEntries</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:aaffc35e18cf3c1ecd25b47dafd869b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bounds of a range that includes all entries with a key that compares equal to the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#aaffc35e18cf3c1ecd25b47dafd869b8f">More...</a><br /></td></tr>
<tr class="separator:aaffc35e18cf3c1ecd25b47dafd869b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ea680d21f189fb166352341c45acb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af5ea680d21f189fb166352341c45acb4">getEntry</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:af5ea680d21f189fb166352341c45acb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the first entry with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#af5ea680d21f189fb166352341c45acb4">More...</a><br /></td></tr>
<tr class="separator:af5ea680d21f189fb166352341c45acb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859b15a0b5468a7c24bc486b4aa369db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a859b15a0b5468a7c24bc486b4aa369db">getEntry</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a859b15a0b5468a7c24bc486b4aa369db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first entry with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a859b15a0b5468a7c24bc486b4aa369db">More...</a><br /></td></tr>
<tr class="separator:a859b15a0b5468a7c24bc486b4aa369db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72291209e83d7b40aa24edc286ca37ca"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a72291209e83d7b40aa24edc286ca37ca">getValue</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a72291209e83d7b40aa24edc286ca37ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-<code>const</code> reference to the first value associated with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a72291209e83d7b40aa24edc286ca37ca">More...</a><br /></td></tr>
<tr class="separator:a72291209e83d7b40aa24edc286ca37ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961824589968da385c7ec5b94ad8d7f9"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a961824589968da385c7ec5b94ad8d7f9">getValue</a> (const Key &amp;key, Value &amp;def_value)</td></tr>
<tr class="memdesc:a961824589968da385c7ec5b94ad8d7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-<code>const</code> reference to the first value associated with the specified key, or the value given by the second argument if an entry with the given key does not exist.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a961824589968da385c7ec5b94ad8d7f9">More...</a><br /></td></tr>
<tr class="separator:a961824589968da385c7ec5b94ad8d7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9852e9920ef2e865b5a7e5fe2bc775"><td class="memItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a2e9852e9920ef2e865b5a7e5fe2bc775">getValue</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a2e9852e9920ef2e865b5a7e5fe2bc775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> reference to the first value associated with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a2e9852e9920ef2e865b5a7e5fe2bc775">More...</a><br /></td></tr>
<tr class="separator:a2e9852e9920ef2e865b5a7e5fe2bc775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3e9d64d3801b7f02cd4468844458b"><td class="memItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#aebb3e9d64d3801b7f02cd4468844458b">getValue</a> (const Key &amp;key, const Value &amp;def_value) const</td></tr>
<tr class="memdesc:aebb3e9d64d3801b7f02cd4468844458b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> reference to the first value associated with the specified key, or the value given by the second argument if an entry with the given key does not exist.  <a href="classCDPL_1_1Util_1_1MultiMap.html#aebb3e9d64d3801b7f02cd4468844458b">More...</a><br /></td></tr>
<tr class="separator:aebb3e9d64d3801b7f02cd4468844458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4f3d13a9b698227496fd54cb88d891"><td class="memItemLeft" align="right" valign="top">Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#add4f3d13a9b698227496fd54cb88d891">operator[]</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:add4f3d13a9b698227496fd54cb88d891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-<code>const</code> reference to the first value associated with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#add4f3d13a9b698227496fd54cb88d891">More...</a><br /></td></tr>
<tr class="separator:add4f3d13a9b698227496fd54cb88d891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe9ca9bcfa65d66944bb1363b979ea6"><td class="memItemLeft" align="right" valign="top">const Value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a2fe9ca9bcfa65d66944bb1363b979ea6">operator[]</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a2fe9ca9bcfa65d66944bb1363b979ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code>const</code> reference to the first value associated with the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a2fe9ca9bcfa65d66944bb1363b979ea6">More...</a><br /></td></tr>
<tr class="separator:a2fe9ca9bcfa65d66944bb1363b979ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816a31216f0be73d4139e2d0d5c4a6dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a816a31216f0be73d4139e2d0d5c4a6dd">removeEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;it)</td></tr>
<tr class="memdesc:a816a31216f0be73d4139e2d0d5c4a6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry pointed to by the iterator <em>it</em> from the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a816a31216f0be73d4139e2d0d5c4a6dd">More...</a><br /></td></tr>
<tr class="separator:a816a31216f0be73d4139e2d0d5c4a6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca27d2e304907cf2137271259d546c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#abca27d2e304907cf2137271259d546c7">removeEntry</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:abca27d2e304907cf2137271259d546c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the first entry with the specified key from the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#abca27d2e304907cf2137271259d546c7">More...</a><br /></td></tr>
<tr class="separator:abca27d2e304907cf2137271259d546c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169b9aaecf4d05aa57c291806f274076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a169b9aaecf4d05aa57c291806f274076">removeEntries</a> (const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;first, const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;last)</td></tr>
<tr class="memdesc:a169b9aaecf4d05aa57c291806f274076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries pointed to by the iterators in the range <em>[first, last)</em> from the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a169b9aaecf4d05aa57c291806f274076">More...</a><br /></td></tr>
<tr class="separator:a169b9aaecf4d05aa57c291806f274076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fcac70f4d8df1fabd5b104d5d24625"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#aa3fcac70f4d8df1fabd5b104d5d24625">removeEntries</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:aa3fcac70f4d8df1fabd5b104d5d24625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries with the specified key from the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#aa3fcac70f4d8df1fabd5b104d5d24625">More...</a><br /></td></tr>
<tr class="separator:aa3fcac70f4d8df1fabd5b104d5d24625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c23ee7e5e2acd3a9ade133fd956d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a72c23ee7e5e2acd3a9ade133fd956d39">insertEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a> &amp;item)</td></tr>
<tr class="memdesc:a72c23ee7e5e2acd3a9ade133fd956d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the key/value pair <em>item</em> into the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a72c23ee7e5e2acd3a9ade133fd956d39">More...</a><br /></td></tr>
<tr class="separator:a72c23ee7e5e2acd3a9ade133fd956d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc07425c9826af033c8d0784948340"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a25cc07425c9826af033c8d0784948340">insertEntry</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a25cc07425c9826af033c8d0784948340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new entry with specified key and value into the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a25cc07425c9826af033c8d0784948340">More...</a><br /></td></tr>
<tr class="separator:a25cc07425c9826af033c8d0784948340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ccdd5d1d740d2710dcdb84d9eedda4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a07ccdd5d1d740d2710dcdb84d9eedda4">insertEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;it, const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a> &amp;item)</td></tr>
<tr class="memdesc:a07ccdd5d1d740d2710dcdb84d9eedda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the key/value pair <em>item</em> into the map and uses the iterator <em>it</em> as a hint for the insertion location.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a07ccdd5d1d740d2710dcdb84d9eedda4">More...</a><br /></td></tr>
<tr class="separator:a07ccdd5d1d740d2710dcdb84d9eedda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64da0cbef3f111bbcb826fcc5890e17b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a64da0cbef3f111bbcb826fcc5890e17b">insertEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;it, const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a64da0cbef3f111bbcb826fcc5890e17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new entry with the specified key and value into the map and uses the iterator <em>it</em> as a hint for the insertion location.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a64da0cbef3f111bbcb826fcc5890e17b">More...</a><br /></td></tr>
<tr class="separator:a64da0cbef3f111bbcb826fcc5890e17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341fae6866eedb61a7895660dde5720f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a341fae6866eedb61a7895660dde5720f">setEntry</a> (const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a> &amp;item)</td></tr>
<tr class="memdesc:a341fae6866eedb61a7895660dde5720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all entries with a key equivalent to that of <em>item</em> with a single entry specified by <em>item</em>.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a341fae6866eedb61a7895660dde5720f">More...</a><br /></td></tr>
<tr class="separator:a341fae6866eedb61a7895660dde5720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552fa86d52015544fc902241b3615f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a6552fa86d52015544fc902241b3615f7">setEntry</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a6552fa86d52015544fc902241b3615f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all entries with a key equivalent to <em>key</em> with a single copy of the key/value pair (<em>key</em>, <em>value</em>).  <a href="classCDPL_1_1Util_1_1MultiMap.html#a6552fa86d52015544fc902241b3615f7">More...</a><br /></td></tr>
<tr class="separator:a6552fa86d52015544fc902241b3615f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9968885bb0f144438cfcf6479cab2dbd"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a9968885bb0f144438cfcf6479cab2dbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a9968885bb0f144438cfcf6479cab2dbd">insertEntries</a> (const InputIter &amp;first, const InputIter &amp;last)</td></tr>
<tr class="memdesc:a9968885bb0f144438cfcf6479cab2dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the key/value pairs in the range <em>[first, last)</em> into the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a9968885bb0f144438cfcf6479cab2dbd">More...</a><br /></td></tr>
<tr class="separator:a9968885bb0f144438cfcf6479cab2dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473da787ffd21bea3853ed8725f02efc"><td class="memTemplParams" colspan="2">template&lt;typename InputIter &gt; </td></tr>
<tr class="memitem:a473da787ffd21bea3853ed8725f02efc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a473da787ffd21bea3853ed8725f02efc">setEntries</a> (const InputIter &amp;first, const InputIter &amp;last)</td></tr>
<tr class="memdesc:a473da787ffd21bea3853ed8725f02efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts new entries or updates the value of existing entries using the key/value pairs in the range <em>[first, last)</em>.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a473da787ffd21bea3853ed8725f02efc">More...</a><br /></td></tr>
<tr class="separator:a473da787ffd21bea3853ed8725f02efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548ce3c75912c6acc73112332614ed32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a548ce3c75912c6acc73112332614ed32">getLowerBound</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a548ce3c75912c6acc73112332614ed32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the first entry whose key is not less than the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a548ce3c75912c6acc73112332614ed32">More...</a><br /></td></tr>
<tr class="separator:a548ce3c75912c6acc73112332614ed32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc421549004beec2750da783b24d2649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adc421549004beec2750da783b24d2649">getLowerBound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:adc421549004beec2750da783b24d2649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first entry whose key is not less than the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#adc421549004beec2750da783b24d2649">More...</a><br /></td></tr>
<tr class="separator:adc421549004beec2750da783b24d2649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586f2ed58938f6c8d259f0cc67aa9315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a586f2ed58938f6c8d259f0cc67aa9315">getUpperBound</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a586f2ed58938f6c8d259f0cc67aa9315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the first entry whose key is greater than the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a586f2ed58938f6c8d259f0cc67aa9315">More...</a><br /></td></tr>
<tr class="separator:a586f2ed58938f6c8d259f0cc67aa9315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3000f2cb86cde3e233c6ff639b46eeda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a3000f2cb86cde3e233c6ff639b46eeda">getUpperBound</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a3000f2cb86cde3e233c6ff639b46eeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first entry whose key is greater than the specified key.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a3000f2cb86cde3e233c6ff639b46eeda">More...</a><br /></td></tr>
<tr class="separator:a3000f2cb86cde3e233c6ff639b46eeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad419bf49ea8a2a770a06fadeb11a689d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ad419bf49ea8a2a770a06fadeb11a689d">getEntriesBegin</a> () const</td></tr>
<tr class="memdesc:ad419bf49ea8a2a770a06fadeb11a689d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ad419bf49ea8a2a770a06fadeb11a689d">More...</a><br /></td></tr>
<tr class="separator:ad419bf49ea8a2a770a06fadeb11a689d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e20631e9866fe95d0352d5ddf80445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af6e20631e9866fe95d0352d5ddf80445">getEntriesBegin</a> ()</td></tr>
<tr class="memdesc:af6e20631e9866fe95d0352d5ddf80445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#af6e20631e9866fe95d0352d5ddf80445">More...</a><br /></td></tr>
<tr class="separator:af6e20631e9866fe95d0352d5ddf80445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bdc5cd6fe43fef3c6235404bb88a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a05bdc5cd6fe43fef3c6235404bb88a67">getEntriesEnd</a> () const</td></tr>
<tr class="memdesc:a05bdc5cd6fe43fef3c6235404bb88a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a05bdc5cd6fe43fef3c6235404bb88a67">More...</a><br /></td></tr>
<tr class="separator:a05bdc5cd6fe43fef3c6235404bb88a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40fbb8f09a5d0873074cb63512ba376"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376">getEntriesEnd</a> ()</td></tr>
<tr class="memdesc:ae40fbb8f09a5d0873074cb63512ba376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376">More...</a><br /></td></tr>
<tr class="separator:ae40fbb8f09a5d0873074cb63512ba376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea88db2d6b64625acd4102de4526f84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#abea88db2d6b64625acd4102de4526f84">begin</a> () const</td></tr>
<tr class="memdesc:abea88db2d6b64625acd4102de4526f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#abea88db2d6b64625acd4102de4526f84">More...</a><br /></td></tr>
<tr class="separator:abea88db2d6b64625acd4102de4526f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65524dc84a5ca55ee462d6fb1bce29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ad65524dc84a5ca55ee462d6fb1bce29c">begin</a> ()</td></tr>
<tr class="memdesc:ad65524dc84a5ca55ee462d6fb1bce29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the beginning of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ad65524dc84a5ca55ee462d6fb1bce29c">More...</a><br /></td></tr>
<tr class="separator:ad65524dc84a5ca55ee462d6fb1bce29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f9045f2696515732c1f9d0459c444b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af0f9045f2696515732c1f9d0459c444b">end</a> () const</td></tr>
<tr class="memdesc:af0f9045f2696515732c1f9d0459c444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#af0f9045f2696515732c1f9d0459c444b">More...</a><br /></td></tr>
<tr class="separator:af0f9045f2696515732c1f9d0459c444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b5a7c5d2c6c83f121848682bf255e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a85b5a7c5d2c6c83f121848682bf255e3">end</a> ()</td></tr>
<tr class="memdesc:a85b5a7c5d2c6c83f121848682bf255e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the end of the map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a85b5a7c5d2c6c83f121848682bf255e3">More...</a><br /></td></tr>
<tr class="separator:a85b5a7c5d2c6c83f121848682bf255e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d51a5ff5679bc963167897464bfab32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">ConstReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a5d51a5ff5679bc963167897464bfab32">getEntriesReverseBegin</a> () const</td></tr>
<tr class="memdesc:a5d51a5ff5679bc963167897464bfab32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the beginning of the reversed map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a5d51a5ff5679bc963167897464bfab32">More...</a><br /></td></tr>
<tr class="separator:a5d51a5ff5679bc963167897464bfab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e29f962ee9e7f77474a14d131d61d94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">ReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a9e29f962ee9e7f77474a14d131d61d94">getEntriesReverseBegin</a> ()</td></tr>
<tr class="memdesc:a9e29f962ee9e7f77474a14d131d61d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the beginning of the reversed map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a9e29f962ee9e7f77474a14d131d61d94">More...</a><br /></td></tr>
<tr class="separator:a9e29f962ee9e7f77474a14d131d61d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f17017810c8b82b6f67507c14dcca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">ConstReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a11f17017810c8b82b6f67507c14dcca0">getEntriesReverseEnd</a> () const</td></tr>
<tr class="memdesc:a11f17017810c8b82b6f67507c14dcca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the end of the reversed map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a11f17017810c8b82b6f67507c14dcca0">More...</a><br /></td></tr>
<tr class="separator:a11f17017810c8b82b6f67507c14dcca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c67e86a91c0ebd6121561b878d1f099"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">ReverseEntryIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a9c67e86a91c0ebd6121561b878d1f099">getEntriesReverseEnd</a> ()</td></tr>
<tr class="memdesc:a9c67e86a91c0ebd6121561b878d1f099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a mutable iterator pointing to the end of the reversed map.  <a href="classCDPL_1_1Util_1_1MultiMap.html#a9c67e86a91c0ebd6121561b878d1f099">More...</a><br /></td></tr>
<tr class="separator:a9c67e86a91c0ebd6121561b878d1f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac8175f94d19614663e64158969585a58"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ac8175f94d19614663e64158969585a58">getClassName</a> () const</td></tr>
<tr class="memdesc:ac8175f94d19614663e64158969585a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the (derived) <a class="el" href="classCDPL_1_1Util_1_1Map.html" title="A unique sorted associative container that maps keys to values.">Map</a> class.  <a href="classCDPL_1_1Util_1_1MultiMap.html#ac8175f94d19614663e64158969585a58">More...</a><br /></td></tr>
<tr class="separator:ac8175f94d19614663e64158969585a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, bool AllowDefValues = false, typename KeyCompFunc = std::less&lt;Key&gt;&gt;<br />
class CDPL::Util::MultiMap&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;</h3>

<p>A multiple sorted associative container that maps keys to values. </p>
<p>Since <code>MultiMap</code> is a sorted associative container, it uses an ordering relation on its keys. Two keys are considered to be equivalent if neither one is less than the other. <code>MultiMap</code> guarantees that the complexity for most operations is never worse than logarithmic, and the entries are always sorted in ascending order by key. It is also a multiple associative container, meaning that there is no limit on the number of entries with the same key. <code>MultiMap</code> has the important property that inserting a new entry does not invalidate iterators that point to existing entries. Erasing an entry also does not invalidate any iterators, except, of course, for iterators that actually point to the entry that is being erased.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the map's keys. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the mapped values. </td></tr>
    <tr><td class="paramname">AllowDefValues</td><td>Whether to return a default value or to throw an exception if a key/value entry is not present in the map. </td></tr>
    <tr><td class="paramname">KeyCompFunc</td><td>The type of a functor class used to establish the strictly weak ordering on the map's keys. The functor has to return <code>true</code> if the first argument is less than the second one, and <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abbdc152b629c0f1b506f2859e3d295a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbdc152b629c0f1b506f2859e3d295a0">&#9670;&nbsp;</a></span>SharedPointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::shared_ptr&lt;<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a>&gt; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#abbdc152b629c0f1b506f2859e3d295a0">SharedPointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A reference-counted smart pointer [<a class="el" href="References.html#SHPTR">SHPTR</a>] for dynamically allocated <code>MultiMap</code> instances. </p>

</div>
</div>
<a id="a025e4ca5a7cfa6ee0120e40d00a6cc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025e4ca5a7cfa6ee0120e40d00a6cc3e">&#9670;&nbsp;</a></span>KeyType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Key <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a025e4ca5a7cfa6ee0120e40d00a6cc3e">KeyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the map's keys. </p>

</div>
</div>
<a id="a915f0735582440d53401c6a2f1249b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f0735582440d53401c6a2f1249b97">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Value <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a915f0735582440d53401c6a2f1249b97">ValueType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the mapped values. </p>

</div>
</div>
<a id="a84e6d586b69b95ce009e2b1f6d48bc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e6d586b69b95ce009e2b1f6d48bc2a">&#9670;&nbsp;</a></span>Entry</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::value_type <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the key/value pairs stored in the map. </p>
<p>The member <code>Entry::first</code> is the <code>const</code> key object of type <em>Key</em> and the member <code>Entry::second</code> is the associated value object of type <em>Value</em>. </p>

</div>
</div>
<a id="af21868fcca73931bf7b0adf68536bf9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21868fcca73931bf7b0adf68536bf9e">&#9670;&nbsp;</a></span>ConstEntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::const_iterator <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant iterator used to iterate over the entries of the map. </p>

</div>
</div>
<a id="ab0da389f14ea618b999767781b2a80ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0da389f14ea618b999767781b2a80ae">&#9670;&nbsp;</a></span>ConstReverseEntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::const_reverse_iterator <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">ConstReverseEntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constant iterator used to iterate backwards over the entries of the map. </p>

</div>
</div>
<a id="a37dcf6383707ea2a3e7bac0fc1ca00b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dcf6383707ea2a3e7bac0fc1ca00b6">&#9670;&nbsp;</a></span>EntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::iterator <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutable iterator used to iterate over the entries of the map. </p>

</div>
</div>
<a id="adae60fa415108ceef98a742838310084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae60fa415108ceef98a742838310084">&#9670;&nbsp;</a></span>ReverseEntryIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef StorageType::reverse_iterator <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">ReverseEntryIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A mutable iterator used to iterate backwards over the entries of the map. </p>

</div>
</div>
<a id="a1f40f0fec5642f1ccb553247a48479c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f40f0fec5642f1ccb553247a48479c9">&#9670;&nbsp;</a></span>EntryIteratorRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>, <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a>&gt; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a1f40f0fec5642f1ccb553247a48479c9">EntryIteratorRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of mutable iterators used to specify the start and end of a range of entries. </p>

</div>
</div>
<a id="a94b9860b1b0f8137f048259e5f69e73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b9860b1b0f8137f048259e5f69e73e">&#9670;&nbsp;</a></span>ConstEntryIteratorRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>, <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a>&gt; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a94b9860b1b0f8137f048259e5f69e73e">ConstEntryIteratorRange</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pair of constant iterators used to specify the start and end of a range of entries. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8f751dfd19cb5d6d24c797e5a7ab7d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f751dfd19cb5d6d24c797e5a7ab7d1a">&#9670;&nbsp;</a></span>MultiMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty map. </p>

</div>
</div>
<a id="a8a3194f5f85d17d25ff4964d78c9a37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a3194f5f85d17d25ff4964d78c9a37d">&#9670;&nbsp;</a></span>MultiMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> </td>
          <td>(</td>
          <td class="paramtype">const KeyCompFunc &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an empty map and uses <em>func</em> as key compare function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The key compare function to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60276ae584ab2f96ce56edec39eeca6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60276ae584ab2f96ce56edec39eeca6b">&#9670;&nbsp;</a></span>MultiMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab99a0d33a7bfdd4c0604ad929d3ad379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99a0d33a7bfdd4c0604ad929d3ad379">&#9670;&nbsp;</a></span>MultiMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyCompFunc &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and initializes the map with copies of the key value pairs in the range <em>[first, last)</em> and uses <em>func</em> as key compare function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
    <tr><td class="paramname">func</td><td>The key compare function to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21140bda55d77f60146aac3e1bdfb27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21140bda55d77f60146aac3e1bdfb27b">&#9670;&nbsp;</a></span>~MultiMap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues = false, typename KeyCompFunc  = std::less&lt;Key&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::~<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa71eed20cfa07a80953c863696a8fa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71eed20cfa07a80953c863696a8fa46">&#9670;&nbsp;</a></span>getData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::StorageType &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a364cf4bd6e43bce343f1622b54ab8c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364cf4bd6e43bce343f1622b54ab8c51">&#9670;&nbsp;</a></span>getData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::StorageType &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getData</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a6a048a8bcb3bb9a60430b292d528b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6a048a8bcb3bb9a60430b292d528b2">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size (number of entries) of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the map. </dd></dl>

</div>
</div>
<a id="aca2ea618effd04f9eb552e85977a36b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2ea618effd04f9eb552e85977a36b8">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::isEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the map is empty (<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a9a6a048a8bcb3bb9a60430b292d528b2" title="Returns the size (number of entries) of the map.">getSize()</a> == 0). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the map is empty, and <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="af4f9134ed1f3751f7aabfcec180d4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f9134ed1f3751f7aabfcec180d4dc6">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases all entries. </p>

</div>
</div>
<a id="a05e4f4f8316da24915ca781a0b09a5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e4f4f8316da24915ca781a0b09a5f9">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents with <em>map</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>The other map with which the contents will be exchanged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac59878b6ac823d2533922eb411f64d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59878b6ac823d2533922eb411f64d86">&#9670;&nbsp;</a></span>getKeyCompareFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">KeyCompFunc <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getKeyCompareFunction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the key compare function used by the map. </p>
<dl class="section return"><dt>Returns</dt><dd>The key compare function. </dd></dl>

</div>
</div>
<a id="a55b4ec5108fe3ccb0164ab226c1ea30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b4ec5108fe3ccb0164ab226c1ea30a">&#9670;&nbsp;</a></span>getNumEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getNumEntries </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of entries with the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entries to count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries with the specified key. </dd></dl>

</div>
</div>
<a id="ac7b020b1d68b64314f850d362b46c8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b020b1d68b64314f850d362b46c8f9">&#9670;&nbsp;</a></span>getEntries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a1f40f0fec5642f1ccb553247a48479c9">EntryIteratorRange</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntries </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounds of a range that includes all entries with a key that compares equal to the specified key. </p>
<p>If <em>key</em> does not match any key in the container, the range returned has a length of zero, with both iterators pointing to the entry with the nearest key greater than <em>key</em>, if any, or to <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a> if <em>key</em> is greater than all the keys in the map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of mutable iterators specifying the start and end of the sequence of entries with the specified key. </dd></dl>

</div>
</div>
<a id="aaffc35e18cf3c1ecd25b47dafd869b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffc35e18cf3c1ecd25b47dafd869b8f">&#9670;&nbsp;</a></span>getEntries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a94b9860b1b0f8137f048259e5f69e73e">ConstEntryIteratorRange</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntries </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bounds of a range that includes all entries with a key that compares equal to the specified key. </p>
<p>If <em>key</em> does not match any key in the container, the range returned has a length of zero, with both iterators pointing to the entry with the nearest key greater than the specified key, if any, or to <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a> if <em>key</em> is greater than all the keys in the map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair of constant iterators specifying the start and end of the sequence of entries with the specified key. </dd></dl>

</div>
</div>
<a id="af5ea680d21f189fb166352341c45acb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ea680d21f189fb166352341c45acb4">&#9670;&nbsp;</a></span>getEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the first entry with the specified key. </p>
<p>If the map does not contain an entry with the specified key, an iterator pointing one past the last entry of the map (<code>== <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a></code>) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing the first entry with the specified key, or <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a> if the map contains no such entry. </dd></dl>

</div>
</div>
<a id="a859b15a0b5468a7c24bc486b4aa369db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859b15a0b5468a7c24bc486b4aa369db">&#9670;&nbsp;</a></span>getEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first entry with the specified key. </p>
<p>If the map does not contain an entry with the specified key, an iterator pointing one past the last entry of the map (<code>== <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a></code>) is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing the first entry with the specified key, or <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ae40fbb8f09a5d0873074cb63512ba376" title="Returns a mutable iterator pointing to the end of the map.">getEntriesEnd()</a> if the map contains no such entry. </dd></dl>

</div>
</div>
<a id="a72291209e83d7b40aa24edc286ca37ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72291209e83d7b40aa24edc286ca37ca">&#9670;&nbsp;</a></span>getValue() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-<code>const</code> reference to the first value associated with the specified key. </p>
<p>If the map contains an entry with the specified key, a reference to the associated value is returned. If the map does not contain the entry and default values are enabled (that is, the template parameter <em>AllowDefValues</em> is <code>true</code>), a new map entry is created which associates <em>key</em> with the default constructed value object. Otherwise, <a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a> is thrown to indicate the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-<code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a961824589968da385c7ec5b94ad8d7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961824589968da385c7ec5b94ad8d7f9">&#9670;&nbsp;</a></span>getValue() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>def_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-<code>const</code> reference to the first value associated with the specified key, or the value given by the second argument if an entry with the given key does not exist. </p>
<p>If the map contains an entry with the specified key, a reference to the associated value is returned. If the map does not contain the entry, the second argument <em>def_value</em> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
    <tr><td class="paramname">def_value</td><td>The value which is returned if the specified entry does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-<code>const</code> reference to the requested or default value. </dd></dl>

</div>
</div>
<a id="a2e9852e9920ef2e865b5a7e5fe2bc775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9852e9920ef2e865b5a7e5fe2bc775">&#9670;&nbsp;</a></span>getValue() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> reference to the first value associated with the specified key. </p>
<p>If the map contains the specified entry, a reference to the associated value is returned. If the map does not contain the entry and default values are enabled (that is, the template parameter <em>AllowDefValues</em> is <code>true</code>), a <code>const</code> reference to a default constructed value object is returned. Otherwise, <a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a> is thrown to indicate the error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a2e9852e9920ef2e865b5a7e5fe2bc775" title="Returns a const reference to the first value associated with the specified key.">getValue(const Key&amp;) const</a> </dd></dl>

</div>
</div>
<a id="aebb3e9d64d3801b7f02cd4468844458b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3e9d64d3801b7f02cd4468844458b">&#9670;&nbsp;</a></span>getValue() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>def_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> reference to the first value associated with the specified key, or the value given by the second argument if an entry with the given key does not exist. </p>
<p>If the map contains an entry with the specified key, a reference to the associated value is returned. If the map does not contain the entry, the second argument <em>def_value</em> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
    <tr><td class="paramname">def_value</td><td>The value which is returned if the specified entry does not exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to the requested or default value. </dd></dl>

</div>
</div>
<a id="add4f3d13a9b698227496fd54cb88d891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4f3d13a9b698227496fd54cb88d891">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a non-<code>const</code> reference to the first value associated with the specified key. </p>
<p>The method is equivalent to <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a72291209e83d7b40aa24edc286ca37ca" title="Returns a non-const reference to the first value associated with the specified key.">getValue(const Key&amp;)</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-<code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a72291209e83d7b40aa24edc286ca37ca" title="Returns a non-const reference to the first value associated with the specified key.">getValue(const Key&amp;)</a> </dd></dl>

</div>
</div>
<a id="a2fe9ca9bcfa65d66944bb1363b979ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe9ca9bcfa65d66944bb1363b979ea6">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Value &amp; <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <code>const</code> reference to the first value associated with the specified key. </p>
<p>The method is equivalent to <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a2e9852e9920ef2e865b5a7e5fe2bc775" title="Returns a const reference to the first value associated with the specified key.">getValue(const Key&amp;) const</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the requested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>const</code> reference to the requested value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a></td><td>if <em>AllowDefValues</em> is <code>false</code> and the map does not contain an entry with the specified key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a2e9852e9920ef2e865b5a7e5fe2bc775" title="Returns a const reference to the first value associated with the specified key.">getValue(const Key&amp;) const</a> </dd></dl>

</div>
</div>
<a id="a816a31216f0be73d4139e2d0d5c4a6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816a31216f0be73d4139e2d0d5c4a6dd">&#9670;&nbsp;</a></span>removeEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the entry pointed to by the iterator <em>it</em> from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator pointing to the entry to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abca27d2e304907cf2137271259d546c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abca27d2e304907cf2137271259d546c7">&#9670;&nbsp;</a></span>removeEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the first entry with the specified key from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entry to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169b9aaecf4d05aa57c291806f274076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169b9aaecf4d05aa57c291806f274076">&#9670;&nbsp;</a></span>removeEntries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all entries pointed to by the iterators in the range <em>[first, last)</em> from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3fcac70f4d8df1fabd5b104d5d24625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3fcac70f4d8df1fabd5b104d5d24625">&#9670;&nbsp;</a></span>removeEntries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::removeEntries </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all entries with the specified key from the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key specifying the entries to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of removed entries. </dd></dl>

</div>
</div>
<a id="a72c23ee7e5e2acd3a9ade133fd956d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c23ee7e5e2acd3a9ade133fd956d39">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the key/value pair <em>item</em> into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The key/value pair to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the inserted entry. </dd></dl>

</div>
</div>
<a id="a25cc07425c9826af033c8d0784948340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cc07425c9826af033c8d0784948340">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new entry with specified key and value into the map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with <em>key</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the inserted entry. </dd></dl>

</div>
</div>
<a id="a07ccdd5d1d740d2710dcdb84d9eedda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ccdd5d1d740d2710dcdb84d9eedda4">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the key/value pair <em>item</em> into the map and uses the iterator <em>it</em> as a hint for the insertion location. </p>
<p>The return value is a dereferenceable iterator that points to the entry with a key that is equivalent to that of <em>item</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator pointing to a location where the insertion position search will begin. </td></tr>
    <tr><td class="paramname">item</td><td>The key/value pair to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the entry with a key that is equivalent to that of <em>item</em>. </dd></dl>

</div>
</div>
<a id="a64da0cbef3f111bbcb826fcc5890e17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64da0cbef3f111bbcb826fcc5890e17b">&#9670;&nbsp;</a></span>insertEntry() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new entry with the specified key and value into the map and uses the iterator <em>it</em> as a hint for the insertion location. </p>
<p>The argument <em>it</em> is a hint and points to the location where the insertion position search will begin. The return value is a dereferenceable iterator that points to the entry with a key that is equivalent to the specified key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>An iterator pointing to a location where the insertion position search will begin. </td></tr>
    <tr><td class="paramname">key</td><td>The key of the entry to insert. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with <em>key</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the entry with a key that is equivalent to the specified key. </dd></dl>

</div>
</div>
<a id="a341fae6866eedb61a7895660dde5720f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341fae6866eedb61a7895660dde5720f">&#9670;&nbsp;</a></span>setEntry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::setEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a84e6d586b69b95ce009e2b1f6d48bc2a">Entry</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all entries with a key equivalent to that of <em>item</em> with a single entry specified by <em>item</em>. </p>
<p>If no entries with a key equivalent to that of <em>item</em> exist, <code>setEntry(item)</code> is equivalent to <code>insertEntry(item)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The key/value pair to insert or with which existing entries will be replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the entry with a key that is equivalent to that of <em>item</em>. </dd></dl>

</div>
</div>
<a id="a6552fa86d52015544fc902241b3615f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552fa86d52015544fc902241b3615f7">&#9670;&nbsp;</a></span>setEntry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::setEntry </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all entries with a key equivalent to <em>key</em> with a single copy of the key/value pair (<em>key</em>, <em>value</em>). </p>
<p>If no entries with a key equivalent to the specified key exist, <code>setEntry(k, v)</code> is equivalent to <code>insertEntry(k, v)</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entries to replace. </td></tr>
    <tr><td class="paramname">value</td><td>The value associated with <em>key</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator that points to the entry with a key that is equivalent to the specified key. </dd></dl>

</div>
</div>
<a id="a9968885bb0f144438cfcf6479cab2dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9968885bb0f144438cfcf6479cab2dbd">&#9670;&nbsp;</a></span>insertEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::insertEntries </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the key/value pairs in the range <em>[first, last)</em> into the map. </p>
<p>This is equivalent to calling <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a72c23ee7e5e2acd3a9ade133fd956d39" title="Inserts the key/value pair item into the map.">insertEntry(const Entry&amp;)</a> for each key/value pair <em>i</em> that is pointed to by an iterator in the range <em>[first, last)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473da787ffd21bea3853ed8725f02efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473da787ffd21bea3853ed8725f02efc">&#9670;&nbsp;</a></span>setEntries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
<div class="memtemplate">
template&lt;typename InputIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::setEntries </td>
          <td>(</td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIter &amp;&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts new entries or updates the value of existing entries using the key/value pairs in the range <em>[first, last)</em>. </p>
<p>This is equivalent to calling <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a341fae6866eedb61a7895660dde5720f" title="Replaces all entries with a key equivalent to that of item with a single entry specified by item.">setEntry(const Entry&amp;)</a> for each key/value pair <em>i</em> that is pointed to by an iterator in the range <em>[first, last)</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a548ce3c75912c6acc73112332614ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548ce3c75912c6acc73112332614ed32">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getLowerBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the first entry whose key is not less than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the first entry whose key is not less than the specified key. </dd></dl>

</div>
</div>
<a id="adc421549004beec2750da783b24d2649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc421549004beec2750da783b24d2649">&#9670;&nbsp;</a></span>getLowerBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getLowerBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first entry whose key is not less than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the first entry whose key is not less than the specified key. </dd></dl>

</div>
</div>
<a id="a586f2ed58938f6c8d259f0cc67aa9315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586f2ed58938f6c8d259f0cc67aa9315">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getUpperBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the first entry whose key is greater than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the first entry whose key is greater than the specified key. </dd></dl>

</div>
</div>
<a id="a3000f2cb86cde3e233c6ff639b46eeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3000f2cb86cde3e233c6ff639b46eeda">&#9670;&nbsp;</a></span>getUpperBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getUpperBound </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first entry whose key is greater than the specified key. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the first entry whose key is greater than the specified key. </dd></dl>

</div>
</div>
<a id="ad419bf49ea8a2a770a06fadeb11a689d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad419bf49ea8a2a770a06fadeb11a689d">&#9670;&nbsp;</a></span>getEntriesBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="af6e20631e9866fe95d0352d5ddf80445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e20631e9866fe95d0352d5ddf80445">&#9670;&nbsp;</a></span>getEntriesBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="a05bdc5cd6fe43fef3c6235404bb88a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bdc5cd6fe43fef3c6235404bb88a67">&#9670;&nbsp;</a></span>getEntriesEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="ae40fbb8f09a5d0873074cb63512ba376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40fbb8f09a5d0873074cb63512ba376">&#9670;&nbsp;</a></span>getEntriesEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="abea88db2d6b64625acd4102de4526f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea88db2d6b64625acd4102de4526f84">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="ad65524dc84a5ca55ee462d6fb1bce29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad65524dc84a5ca55ee462d6fb1bce29c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::begin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the beginning of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the beginning of the map. </dd></dl>

</div>
</div>
<a id="af0f9045f2696515732c1f9d0459c444b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f9045f2696515732c1f9d0459c444b">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#af21868fcca73931bf7b0adf68536bf9e">ConstEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="a85b5a7c5d2c6c83f121848682bf255e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b5a7c5d2c6c83f121848682bf255e3">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#a37dcf6383707ea2a3e7bac0fc1ca00b6">EntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the end of the map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the end of the map. </dd></dl>

</div>
</div>
<a id="a5d51a5ff5679bc963167897464bfab32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d51a5ff5679bc963167897464bfab32">&#9670;&nbsp;</a></span>getEntriesReverseBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">ConstReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the beginning of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the beginning of the reversed map. </dd></dl>

</div>
</div>
<a id="a9e29f962ee9e7f77474a14d131d61d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e29f962ee9e7f77474a14d131d61d94">&#9670;&nbsp;</a></span>getEntriesReverseBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">ReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseBegin</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the beginning of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the beginning of the reversed map. </dd></dl>

</div>
</div>
<a id="a11f17017810c8b82b6f67507c14dcca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f17017810c8b82b6f67507c14dcca0">&#9670;&nbsp;</a></span>getEntriesReverseEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ab0da389f14ea618b999767781b2a80ae">ConstReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the end of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant iterator pointing to the end of the reversed map. </dd></dl>

</div>
</div>
<a id="a9c67e86a91c0ebd6121561b878d1f099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c67e86a91c0ebd6121561b878d1f099">&#9670;&nbsp;</a></span>getEntriesReverseEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::<a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#adae60fa415108ceef98a742838310084">ReverseEntryIterator</a> <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getEntriesReverseEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a mutable iterator pointing to the end of the reversed map. </p>
<dl class="section return"><dt>Returns</dt><dd>A mutable iterator pointing to the end of the reversed map. </dd></dl>

</div>
</div>
<a id="ac8175f94d19614663e64158969585a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8175f94d19614663e64158969585a58">&#9670;&nbsp;</a></span>getClassName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , bool AllowDefValues, typename KeyCompFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html">CDPL::Util::MultiMap</a>&lt; Key, Value, AllowDefValues, KeyCompFunc &gt;::getClassName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the (derived) <a class="el" href="classCDPL_1_1Util_1_1Map.html" title="A unique sorted associative container that maps keys to values.">Map</a> class. </p>
<p>Overriding this method provides an easy way to customize exception messages with the name of a derived class. Consider the class <code>MyMultiMap</code> which inherits publicly from <code>MultiMap&lt;int, int&gt;</code> and overrides <a class="el" href="classCDPL_1_1Util_1_1MultiMap.html#ac8175f94d19614663e64158969585a58" title="Returns the name of the (derived) Map class.">getClassName()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMap : <span class="keyword">public</span> Map&lt;int, int&gt;</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">   .....</div>
<div class="line"> </div>
<div class="line">private:</div>
<div class="line">   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classCDPL_1_1Util_1_1MultiMap.html#ac8175f94d19614663e64158969585a58">getClassName</a>()<span class="keyword"> const </span>{</div>
<div class="line">      <span class="keywordflow">return</span> <span class="stringliteral">&quot;MyMultiMap&quot;</span>;</div>
<div class="line">   }</div>
<div class="line">};</div>
</div><!-- fragment --><p>If, for example, the requested value for a particular key is not found, the error message of the thrown <a class="el" href="classCDPL_1_1Base_1_1ItemNotFound.html" title="Thrown to indicate that some requested data item could not be found.">Base::ItemNotFound</a> exception will now start with "MyMultiMap: ...." instead of the default "MultiMap: ....".</p>
<dl class="section return"><dt>Returns</dt><dd>The name of the class as a C-string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classCDPL_1_1Util_1_1Array.html#a0f8a06b8703c4519b8c400620ba4a9b1" title="Returns the name of the (derived) array class.">Array::getClassName</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MultiMap_8hpp_source.html">MultiMap.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassCDPL_1_1Util_1_1MultiMap_html_ac8175f94d19614663e64158969585a58"><div class="ttname"><a href="classCDPL_1_1Util_1_1MultiMap.html#ac8175f94d19614663e64158969585a58">CDPL::Util::MultiMap::getClassName</a></div><div class="ttdeci">virtual const char * getClassName() const</div><div class="ttdoc">Returns the name of the (derived) Map class.</div><div class="ttdef"><b>Definition:</b> MultiMap.hpp:1064</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
